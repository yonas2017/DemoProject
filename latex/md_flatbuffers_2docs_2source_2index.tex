\chapter{Overview}
\hypertarget{md_flatbuffers_2docs_2source_2index}{}\label{md_flatbuffers_2docs_2source_2index}\index{Overview@{Overview}}
Flat\+Buffers is an efficient cross platform serialization library for C++, C\#, C, Go, Java, Kotlin, Java\+Script, Lobster, Lua, Type\+Script, PHP, Python, Rust and Swift. It was originally created at \doxylink{namespaceGoogle}{Google} for game development and other performance-\/critical applications.

It is available as Open Source on \href{https://github.com/google/flatbuffers}{\texttt{ Git\+Hub}} under the Apache license v2.\+0.

\doxysection*{Why Use Flat\+Buffers?}




\begin{DoxyItemize}
\item \+:material-\/clock-\/fast\+:\{ .lg .middle \} {\bfseries{Access to serialized data without parsing/unpacking}}
\end{DoxyItemize}

\DoxyHorRuler{0}
 Access the data directly without unpacking or parsing.


\begin{DoxyItemize}
\item \+:material-\/memory\+:\{ .lg .middle \} {\bfseries{Memory Efficiency and Speed}}
\end{DoxyItemize}

\DoxyHorRuler{0}
 The only memory needed to access your data is that of the buffer. No heap is required.


\begin{DoxyItemize}
\item \+:material-\/compare-\/horizontal\+:\{ .lg .middle \} {\bfseries{Backwards and Forwards Compatibility}}
\end{DoxyItemize}

\DoxyHorRuler{0}
 The only memory needed to access your data is that of the buffer. No heap is required.


\begin{DoxyItemize}
\item \+:material-\/scale-\/off\+:\{ .lg .middle \} {\bfseries{Small Footprint}}
\end{DoxyItemize}

\DoxyHorRuler{0}
 Minimal dependencies and small code footprint.



\doxysection*{Why not use...}

=== "{}\+Protocol Buffers"{} \begin{DoxyVerb}Protocol Buffers is indeed relatively similar to FlatBuffers, with the primary
difference being that FlatBuffers does not need a parsing/unpacking step to a
secondary representation before you can access data, often coupled with
per-object memory allocation. The code is an order of magnitude bigger, too.
\end{DoxyVerb}
 === "{}\+JSON"{} \begin{DoxyVerb}JSON is very readable (which is why we use it as our optional text format) and
very convenient when used together with dynamically typed languages (such as
JavaScript). When serializing data from statically typed languages, however,
JSON not only has the obvious drawback of runtime inefficiency, but also forces
you to write more code to access data (counterintuitively) due to its
dynamic-typing serialization system. In this context, it is only a better choice
for systems that have very little to no information ahead of time about what
data needs to be stored.
\end{DoxyVerb}
 