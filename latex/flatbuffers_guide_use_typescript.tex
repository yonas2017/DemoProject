\chapter{Use in Type\+Script}
\hypertarget{flatbuffers_guide_use_typescript}{}\label{flatbuffers_guide_use_typescript}\index{Use in TypeScript@{Use in TypeScript}}
\doxysection*{Before you get started}

Before diving into the Flat\+Buffers usage in Type\+Script, it should be noted that the \doxysectlink{flatbuffers_guide_tutorial}{Tutorial}{0} page has a complete guide to general Flat\+Buffers usage in all of the supported languages (including Type\+Script). This page is specifically designed to cover the nuances of Flat\+Buffers usage in Type\+Script.

You should also have read the \doxysectlink{flatbuffers_guide_building}{Building}{0} documentation to build {\ttfamily flatc} and should be familiar with \doxysectlink{flatbuffers_guide_using_schema_compiler}{Using the schema compiler}{0} and \doxysectlink{flatbuffers_guide_writing_schema}{Writing a schema}{0}.

\doxysection*{Flat\+Buffers Type\+Script library code location}

The code for the Flat\+Buffers Type\+Script library can be found at \href{https://www.npmjs.com/package/flatbuffers}{\texttt{ https\+://www.\+npmjs.\+com/package/flatbuffers}}.

\doxysection*{Testing the Flat\+Buffers Type\+Script library}

To run the tests, use the \href{https://github.com/google/
flatbuffers/blob/master/tests/TypeScriptTest.py}{\texttt{ Type\+Script\+Test.\+py}} Python3 script.

{\itshape Note\+: The Type\+Script test file requires \href{https://nodejs.org/en/}{\texttt{ Node.\+js}}.}

\doxysection*{Using the Flat\+Buffers Type\+Script library}

{\itshape Note\+: See \doxysectlink{flatbuffers_guide_tutorial}{Tutorial}{0} for a more in-\/depth example of how to use Flat\+Buffers in Type\+Script.}

Flat\+Buffers supports both reading and writing Flat\+Buffers in Type\+Script.

To use Flat\+Buffers in your own code, first generate Type\+Script classes from your schema with the {\ttfamily -\/-\/ts} option to {\ttfamily flatc}. Then you can include both Flat\+Buffers and the generated code to read or write a Flat\+Buffer.

For example, here is how you would read a Flat\+Buffer binary file in Type\+Script\+: First, include the library and generated code. Then read the file into an {\ttfamily Uint8\+Array}. Make a {\ttfamily flatbuffers.\+Byte\+Buffer} out of the {\ttfamily Uint8\+Array}, and pass the Byte\+Buffer to the {\ttfamily get\+Root\+As\+Monster} function.


\begin{DoxyCode}{0}
\DoxyCodeLine{import\ *\ as\ flatbuffers\ from\ 'flatbuffers';}
\DoxyCodeLine{}
\DoxyCodeLine{import\ \{\ MyGame\ \}\ from\ './monster\_generated';}
\DoxyCodeLine{}
\DoxyCodeLine{let\ data\ =\ new\ Uint8Array(fs.readFileSync('monster.dat'));}
\DoxyCodeLine{let\ buf\ =\ new\ flatbuffers.ByteBuffer(data);}
\DoxyCodeLine{}
\DoxyCodeLine{let\ monster\ =\ MyGame.Example.Monster.getRootAsMonster(buf);}

\end{DoxyCode}


Now you can access values like this\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{let\ hp\ =\ monster.hp();}
\DoxyCodeLine{let\ pos\ =\ monster.pos();}

\end{DoxyCode}


\doxysection*{Object based API}

Flat\+Buffers is all about memory efficiency, which is why its base API is written around using as little as possible of it. This does make the API clumsier (requiring pre-\/order construction of all data, and making mutation harder).

For times when efficiency is less important a more convenient object based API can be used (through {\ttfamily -\/-\/gen-\/object-\/api}) that is able to unpack \& pack a Flat\+Buffer into objects and standard TS types.

To use\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{//\ Autogenerated\ class\ from\ table\ Monster.}
\DoxyCodeLine{let\ monsterobj\ =\ new\ MonsterT();}
\DoxyCodeLine{}
\DoxyCodeLine{//\ Deserialize\ from\ buffer\ into\ object.}
\DoxyCodeLine{Monster.getRootAsMonster(flatbuffer).unpackTo(monsterobj);}
\DoxyCodeLine{//\ or}
\DoxyCodeLine{let\ monsterobj\ =\ Monster.getRootAsMonster(flatbuffer).unpack();}
\DoxyCodeLine{}
\DoxyCodeLine{//\ Update\ object\ directly\ like\ a\ regular\ TS\ class\ instance.}
\DoxyCodeLine{console.log(monsterobj.name);}
\DoxyCodeLine{monsterobj.name\ =\ "{}Bob"{};}
\DoxyCodeLine{}
\DoxyCodeLine{//\ Serialize\ into\ new\ flatbuffer.}
\DoxyCodeLine{let\ fbb\ =\ new\ flatbuffers.Builder(1);}
\DoxyCodeLine{Monster.finishMonsterBuffer(fbb,\ monsterobj.pack(fbb));}

\end{DoxyCode}


\doxysection*{Text parsing Flat\+Buffers in Type\+Script}

There currently is no support for parsing text (Schema\textquotesingle{}s and JSON) directly from Type\+Script. 