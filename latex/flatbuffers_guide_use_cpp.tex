\chapter{Use in C++}
\hypertarget{flatbuffers_guide_use_cpp}{}\label{flatbuffers_guide_use_cpp}\index{Use in C++@{Use in C++}}
\doxysection*{Before you get started}

Before diving into the Flat\+Buffers usage in C++, it should be noted that the \doxysectlink{flatbuffers_guide_tutorial}{Tutorial}{0} page has a complete guide to general Flat\+Buffers usage in all of the supported languages (including C++). This page is designed to cover the nuances of Flat\+Buffers usage, specific to C++.

\doxysubsubsection*{Prerequisites}

This page assumes you have written a Flat\+Buffers schema and compiled it with the Schema Compiler. If you have not, please see \doxysectlink{flatbuffers_guide_using_schema_compiler}{Using the schema compiler}{0} and \doxysectlink{flatbuffers_guide_writing_schema}{Writing a schema}{0}.

Assuming you wrote a schema, say {\ttfamily mygame.\+fbs} (though the extension doesn\textquotesingle{}t matter), you\textquotesingle{}ve generated a C++ header called {\ttfamily mygame\+\_\+generated.\+h} using the compiler (e.\+g. {\ttfamily flatc -\/c mygame.\+fbs}), you can now start using this in your program by including the header. As noted, this header relies on {\ttfamily \doxylink{flatbuffers_8h}{flatbuffers/flatbuffers.\+h}}, which should be in your include path.

\doxysection*{Flat\+Buffers C++ library code location}

The code for the Flat\+Buffers C++ library can be found at {\ttfamily flatbuffers/include/flatbuffers}. You can browse the library code on the \href{https://github.com/google/flatbuffers/tree/master/include/flatbuffers}{\texttt{ Flat\+Buffers Git\+Hub page}}.

\doxysection*{Testing the Flat\+Buffers C++ library}

The code to test the C++ library can be found at {\ttfamily flatbuffers/tests}. The test code itself is located in \href{https://github.com/google/flatbuffers/blob/master/tests/test.cpp}{\texttt{ test.\+cpp}}.

This test file is built alongside {\ttfamily flatc}. To review how to build the project, please read the \doxysectlink{flatbuffers_guide_building}{Building}{0} documentation.

To run the tests, execute {\ttfamily flattests} from the root {\ttfamily flatbuffers/} directory. For example, on \href{https://en.wikipedia.org/wiki/Linux}{\texttt{ Linux}}, you would simply run\+: {\ttfamily ./flattests}.

\doxysection*{Using the Flat\+Buffers C++ library}

{\itshape Note\+: See \doxysectlink{flatbuffers_guide_tutorial}{Tutorial}{0} for a more in-\/depth example of how to use Flat\+Buffers in C++.}

Flat\+Buffers supports both reading and writing Flat\+Buffers in C++.

To use Flat\+Buffers in your code, first generate the C++ classes from your schema with the {\ttfamily -\/-\/cpp} option to {\ttfamily flatc}. Then you can include both Flat\+Buffers and the generated code to read or write Flat\+Buffers.

For example, here is how you would read a Flat\+Buffer binary file in C++\+: First, include the library and generated code. Then read the file into a {\ttfamily char \texorpdfstring{$\ast$}{*}} array, which you pass to {\ttfamily Get\+Monster()}.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include\ "{}\mbox{\hyperlink{flatbuffers_8h}{flatbuffers/flatbuffers.h}}"{}}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include\ "{}monster\_test\_generate.h"{}}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include\ <iostream>}\ \textcolor{comment}{//\ C++\ header\ file\ for\ printing}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include\ <fstream>}\ \textcolor{comment}{//\ C++\ header\ file\ for\ file\ access}}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{std::ifstream\ infile;}
\DoxyCodeLine{infile.open(\textcolor{stringliteral}{"{}monsterdata\_test.mon"{}},\ std::ios::binary\ |\ std::ios::in);}
\DoxyCodeLine{infile.seekg(0,std::ios::end);}
\DoxyCodeLine{\textcolor{keywordtype}{int}\ length\ =\ infile.tellg();}
\DoxyCodeLine{infile.seekg(0,std::ios::beg);}
\DoxyCodeLine{\textcolor{keywordtype}{char}\ *\mbox{\hyperlink{namespacegenerate__code_aebc120e8b184d051fc85a24ac04dc891}{data}}\ =\ \textcolor{keyword}{new}\ \textcolor{keywordtype}{char}[length];}
\DoxyCodeLine{infile.read(data,\ length);}
\DoxyCodeLine{infile.close();}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{auto}\ monster\ =\ \mbox{\hyperlink{namespaceMyGame_1_1Sample_aeffc316d8b80546edb0f37b6ec9f8d7b}{GetMonster}}(data);}

\end{DoxyCode}


{\ttfamily monster} is of type {\ttfamily Monster \texorpdfstring{$\ast$}{*}}, and points to somewhere {\itshape inside} your buffer (root object pointers are not the same as {\ttfamily buffer\+\_\+pointer} !). If you look in your generated header, you\textquotesingle{}ll see it has convenient accessors for all fields, e.\+g. {\ttfamily hp()}, {\ttfamily mana()}, etc\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{std::cout\ <<\ \textcolor{stringliteral}{"{}hp\ :\ "{}}\ <<\ monster-\/>hp()\ <<\ std::endl;\ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ '80'}}
\DoxyCodeLine{std::cout\ <<\ \textcolor{stringliteral}{"{}mana\ :\ "{}}\ <<\ monster-\/>mana()\ <<\ std::endl;\ \ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ default\ value\ of\ '150'}}
\DoxyCodeLine{std::cout\ <<\ \textcolor{stringliteral}{"{}name\ :\ "{}}\ <<\ monster-\/>name()-\/>c\_str()\ <<\ std::endl;\ \textcolor{comment}{//\ "{}MyMonster"{}}}

\end{DoxyCode}


{\itshape Note\+: That we never stored a {\ttfamily mana} value, so it will return the default.}

The following attributes are supported\+:


\begin{DoxyItemize}
\item {\ttfamily shared} (on a field)\+: For string fields, this enables the usage of string pooling (i.\+e. {\ttfamily Create\+Shared\+String}) as default serialization behavior.

Specifically, {\ttfamily Create\+Xxx\+Direct} functions and {\ttfamily Pack} functions for object based API (see below) will use {\ttfamily Create\+Shared\+String} to create strings.
\end{DoxyItemize}\hypertarget{flatbuffers_guide_use_cpp_flatbuffers_cpp_object_based_api}{}\doxysection{\texorpdfstring{Object based API}{Object based API}}\label{flatbuffers_guide_use_cpp_flatbuffers_cpp_object_based_api}
Flat\+Buffers is all about memory efficiency, which is why its base API is written around using as little as possible of it. This does make the API clumsier (requiring pre-\/order construction of all data, and making mutation harder).

For times when efficiency is less important a more convenient object based API can be used (through {\ttfamily -\/-\/gen-\/object-\/api}) that is able to unpack \& pack a Flat\+Buffer into objects and standard STL containers, allowing for convenient construction, access and mutation.

To use\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{//\ Autogenerated\ class\ from\ table\ Monster.}}
\DoxyCodeLine{MonsterT\ monsterobj;}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ Deserialize\ from\ buffer\ into\ object.}}
\DoxyCodeLine{\mbox{\hyperlink{namespaceMyGame_1_1Sample_aeffc316d8b80546edb0f37b6ec9f8d7b}{GetMonster}}(flatbuffer)-\/>UnPackTo(\&monsterobj);}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ Update\ object\ directly\ like\ a\ C++\ class\ instance.}}
\DoxyCodeLine{cout\ <<\ monsterobj.name;\ \ \textcolor{comment}{//\ This\ is\ now\ a\ std::string!}}
\DoxyCodeLine{monsterobj.name\ =\ \textcolor{stringliteral}{"{}Bob"{}};\ \ \textcolor{comment}{//\ Change\ the\ name.}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ Serialize\ into\ new\ flatbuffer.}}
\DoxyCodeLine{\mbox{\hyperlink{classFlatBufferBuilder}{FlatBufferBuilder}}\ fbb;}
\DoxyCodeLine{fbb.Finish(Monster::Pack(fbb,\ \&monsterobj));}

\end{DoxyCode}


The following attributes are specific to the object-\/based API code generation\+:


\begin{DoxyItemize}
\item {\ttfamily native\+\_\+inline} (on a field)\+: Because Flat\+Buffer tables and structs are optionally present in a given buffer, they are best represented as pointers (specifically std\+::unique\+\_\+ptrs) in the native class since they can be null. This attribute changes the member declaration to use the type directly rather than wrapped in a unique\+\_\+ptr.
\item {\ttfamily native\+\_\+default("{}value"{})} (on a field)\+: For members that are declared "{}native\+\_\+inline"{}, the value specified with this attribute will be included verbatim in the class constructor initializer list for this member.
\item {\ttfamily native\+\_\+custom\+\_\+alloc("{}custom\+\_\+allocator"{})} (on a table or struct)\+: When using the object-\/based API all generated Native\+Tables that are allocated when unpacking your flatbuffer will use "{}custom allocator"{}. The allocator is also used by any std\+::vector that appears in a table defined with {\ttfamily native\+\_\+custom\+\_\+alloc}. This can be used to provide allocation from a pool for example, for faster unpacking when using the object-\/based API.
\end{DoxyItemize}

Minimal Example\+:

schema\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{table\ mytable(native\_custom\_alloc:\textcolor{stringliteral}{"{}custom\_allocator"{}})\ \{}
\DoxyCodeLine{\ \ ...}
\DoxyCodeLine{\}}

\end{DoxyCode}


with {\ttfamily custom\+\_\+allocator} defined before {\ttfamily \doxylink{flatbuffers_8h}{flatbuffers.\+h}} is included, as\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>\ \textcolor{keyword}{struct\ }custom\_allocator\ :\ \textcolor{keyword}{public}\ std::allocator<T>\ \{}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \textcolor{keyword}{typedef}\ T\ *pointer;}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{class}\ U>}
\DoxyCodeLine{\ \ \textcolor{keyword}{struct\ }rebind\ \{}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{typedef}\ custom\_allocator<U>\ other;}
\DoxyCodeLine{\ \ \};}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ pointer\ allocate(\textcolor{keyword}{const}\ std::size\_t\ n)\ \{}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{return}\ std::allocator<T>::allocate(n);}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \textcolor{keywordtype}{void}\ deallocate(T*\ ptr,\ std::size\_t\ n)\ \{}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{return}\ std::allocator<T>::deallocate(ptr,n);}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ custom\_allocator()\ throw()\ \{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{class}\ U>}
\DoxyCodeLine{\ \ custom\_allocator(\textcolor{keyword}{const}\ custom\_allocator<U>\&)\ \textcolor{keywordflow}{throw}()\ \{\}}
\DoxyCodeLine{\};}

\end{DoxyCode}



\begin{DoxyItemize}
\item {\ttfamily native\+\_\+type("{}type"{})} (on a struct)\+: In some cases, a more optimal C++ data type exists for a given struct. For example, the following schema\+:
\end{DoxyItemize}


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{struct\ }Vec2\ \{}
\DoxyCodeLine{\ \ \mbox{\hyperlink{gmock-matchers-containers__test_8cc_a6150e0515f7202e2fb518f7206ed97dc}{x}}:\ float;}
\DoxyCodeLine{\ \ \mbox{\hyperlink{gmock-matchers-containers__test_8cc_a39cb44155237f0205e0feb931d5acbed}{y}}:\ float;}
\DoxyCodeLine{\}}

\end{DoxyCode}


generates the following Object-\/\+Based API class\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{struct\ }Vec2T\ :\ \mbox{\hyperlink{structflatbuffers_1_1NativeTable}{flatbuffers::NativeTable}}\ \{}
\DoxyCodeLine{\ \ \textcolor{keywordtype}{float}\ \mbox{\hyperlink{gmock-matchers-containers__test_8cc_a6150e0515f7202e2fb518f7206ed97dc}{x}};}
\DoxyCodeLine{\ \ \textcolor{keywordtype}{float}\ \mbox{\hyperlink{gmock-matchers-containers__test_8cc_a39cb44155237f0205e0feb931d5acbed}{y}};}
\DoxyCodeLine{\};}

\end{DoxyCode}


However, it can be useful to instead use a user-\/defined C++ type since it can provide more functionality, eg.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{struct\ }vector2\ \{}
\DoxyCodeLine{\ \ \textcolor{keywordtype}{float}\ \mbox{\hyperlink{gmock-matchers-containers__test_8cc_a6150e0515f7202e2fb518f7206ed97dc}{x}}\ =\ 0,\ \mbox{\hyperlink{gmock-matchers-containers__test_8cc_a39cb44155237f0205e0feb931d5acbed}{y}}\ =\ 0;}
\DoxyCodeLine{\ \ vector2\ operator+(vector2\ rhs)\textcolor{keyword}{\ const\ }\{\ ...\ \}}
\DoxyCodeLine{\ \ vector2\ operator-\/(vector2\ rhs)\textcolor{keyword}{\ const\ }\{\ ...\ \}}
\DoxyCodeLine{\ \ \textcolor{keywordtype}{float}\ length()\textcolor{keyword}{\ const\ }\{\ ...\ \}}
\DoxyCodeLine{\ \ \textcolor{comment}{//\ etc.}}
\DoxyCodeLine{\};}

\end{DoxyCode}


The {\ttfamily native\+\_\+type} attribute will replace the usage of the generated class with the given type. So, continuing with the example, the generated code would use {\ttfamily vector2} in place of {\ttfamily Vec2T} for all generated code of the Object-\/\+Based API.

However, because the {\ttfamily native\+\_\+type} is unknown to flatbuffers, the user must provide the following functions to aide in the serialization process\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{namespace\ }\mbox{\hyperlink{namespaceflatbuffers}{flatbuffers}}\ \{}
\DoxyCodeLine{\ \ Vec2\ \mbox{\hyperlink{namespaceflatbuffers_acfc7ca1fa2c229666815f8cc67643524}{Pack}}(\textcolor{keyword}{const}\ vector2\&\ obj);}
\DoxyCodeLine{\ \ vector2\ \mbox{\hyperlink{namespaceflatbuffers_a5fea507e495ecad734b697b029cef510}{UnPack}}(\textcolor{keyword}{const}\ Vec2\&\ obj);}
\DoxyCodeLine{\}}

\end{DoxyCode}



\begin{DoxyItemize}
\item {\ttfamily native\+\_\+type\+\_\+pack\+\_\+name("{}name"{})} (on a struct when {\ttfamily native\+\_\+type} is specified, too)\+: when you want to use the same {\ttfamily native\+\_\+type} multiple times (e. g. with different precision) you must make the names of the Pack/\+Un\+Pack functions unique, otherwise you will run into compile errors. This attribute appends a name to the expected Pack/\+Un\+Pack functions. So when you specify {\ttfamily native\+\_\+type\+\_\+pack\+\_\+name("{}\+Vec2"{})} in the above example you now need to implement these serialization functions instead\+:
\end{DoxyItemize}


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{namespace\ }\mbox{\hyperlink{namespaceflatbuffers}{flatbuffers}}\ \{}
\DoxyCodeLine{\ \ Vec2\ PackVec2(\textcolor{keyword}{const}\ vector2\&\ obj);}
\DoxyCodeLine{\ \ vector2\ UnPackVec2(\textcolor{keyword}{const}\ Vec2\&\ obj);}
\DoxyCodeLine{\}}

\end{DoxyCode}


Finally, the following top-\/level attributes\+:


\begin{DoxyItemize}
\item {\ttfamily native\+\_\+include("{}path"{})} (at file level)\+: Because the {\ttfamily native\+\_\+type} attribute can be used to introduce types that are unknown to flatbuffers, it may be necessary to include "{}external"{} header files in the generated code. This attribute can be used to directly add an \#include directive to the top of the generated code that includes the specified path directly.
\item {\ttfamily force\+\_\+align}\+: this attribute may not be respected in the object API, depending on the aligned of the allocator used with {\ttfamily new}.
\end{DoxyItemize}

\doxysection*{External references}

An additional feature of the object API is the ability to allow you to load multiple independent Flat\+Buffers, and have them refer to eachothers objects using hashes which are then represented as typed pointers in the object API.

To make this work have a field in the objects you want to referred to which is using the string hashing feature (see {\ttfamily hash} attribute in the \doxysectlink{flatbuffers_guide_writing_schema}{schema}{0} documentation). Then you have a similar hash in the field referring to it, along with a {\ttfamily cpp\+\_\+type} attribute specifying the C++ type this will refer to (this can be any C++ type, and will get a {\ttfamily \texorpdfstring{$\ast$}{*}} added).

Then, in JSON or however you create these buffers, make sure they use the same string (or hash).

When you call {\ttfamily Un\+Pack} (or {\ttfamily Create}), you\textquotesingle{}ll need a function that maps from hash to the object (see {\ttfamily resolver\+\_\+function\+\_\+t} for details).

\doxysection*{Using different pointer types}

By default the object tree is built out of {\ttfamily std\+::unique\+\_\+ptr}, but you can influence this either globally (using the {\ttfamily -\/-\/cpp-\/ptr-\/type} argument to {\ttfamily flatc}) or per field (using the {\ttfamily cpp\+\_\+ptr\+\_\+type} attribute) to by any smart pointer type ({\ttfamily my\+\_\+ptr\texorpdfstring{$<$}{<}T\texorpdfstring{$>$}{>}}), or by specifying {\ttfamily naked} as the type to get {\ttfamily T \texorpdfstring{$\ast$}{*}} pointers. Unlike the smart pointers, naked pointers do not manage memory for you, so you\textquotesingle{}ll have to manage their lifecycles manually. To reference the pointer type specified by the {\ttfamily -\/-\/cpp-\/ptr-\/type} argument to {\ttfamily flatc} from a flatbuffer field set the {\ttfamily cpp\+\_\+ptr\+\_\+type} attribute to {\ttfamily default\+\_\+ptr\+\_\+type}.

\doxysection*{Using different string type}

By default the object tree is built out of {\ttfamily std\+::string}, but you can influence this either globally (using the {\ttfamily -\/-\/cpp-\/str-\/type} argument to {\ttfamily flatc}) or per field using the {\ttfamily cpp\+\_\+str\+\_\+type} attribute.

The type must support {\ttfamily T\+::c\+\_\+str()}, {\ttfamily T\+::length()} and {\ttfamily T\+::empty()} as member functions.

Further, the type must be constructible from std\+::string, as by default a std\+::string instance is constructed and then used to initialize the custom string type. This behavior impedes efficient and zero-\/copy construction of custom string types; the {\ttfamily -\/-\/cpp-\/str-\/flex-\/ctor} argument to {\ttfamily flatc} or the per field attribute {\ttfamily cpp\+\_\+str\+\_\+flex\+\_\+ctor} can be used to change this behavior, so that the custom string type is constructed by passing the pointer and length of the Flat\+Buffers String. The custom string class will require a constructor in the following format\+: {\ttfamily custom\+\_\+str\+\_\+class(const char \texorpdfstring{$\ast$}{*}, size\+\_\+t)}. Please note that the character array is not guaranteed to be NULL terminated, you should always use the provided size to determine end of string.

\doxysubsection*{Reflection (\& Resizing)}

There is experimental support for reflection in Flat\+Buffers, allowing you to read and write data even if you don\textquotesingle{}t know the exact format of a buffer, and even allows you to change sizes of strings and vectors in-\/place.

The way this works is very elegant; there is actually a Flat\+Buffer schema that describes schemas (!) which you can find in {\ttfamily reflection/reflection.\+fbs}. The compiler, {\ttfamily flatc}, can write out any schemas it has just parsed as a binary Flat\+Buffer, corresponding to this meta-\/schema.

Loading in one of these binary schemas at runtime allows you traverse any Flat\+Buffer data that corresponds to it without knowing the exact format. You can query what fields are present, and then read/write them after.

For convenient field manipulation, you can include the header {\ttfamily \doxylink{reflection_8h}{flatbuffers/reflection.\+h}} which includes both the generated code from the meta schema, as well as a lot of helper functions.

And example of usage, for the time being, can be found in {\ttfamily \doxylink{test_8cpp}{test.\+cpp}/\+Reflection\+Test()}.

\doxysubsection*{Mini Reflection}

A more limited form of reflection is available for direct inclusion in generated code, which doesn\textquotesingle{}t do any (binary) schema access at all. It was designed to keep the overhead of reflection as low as possible (on the order of 2-\/6 bytes per field added to your executable), but doesn\textquotesingle{}t contain all the information the (binary) schema contains.

You add this information to your generated code by specifying {\ttfamily -\/-\/reflect-\/types} (or instead {\ttfamily -\/-\/reflect-\/names} if you also want field / enum names).

You can now use this information, for example to print a Flat\+Buffer to text\+: \begin{DoxyVerb}auto s = flatbuffers::FlatBufferToString(flatbuf, MonsterTypeTable());
\end{DoxyVerb}
 {\ttfamily Monster\+Type\+Table()} is declared in the generated code for each type. The string produced is very similar to the JSON produced by the {\ttfamily Parser} based text generator.

You\textquotesingle{}ll need {\ttfamily \doxylink{minireflect_8h}{flatbuffers/minireflect.\+h}} for this functionality. In there is also a convenient visitor/iterator so you can write your own output / functionality based on the mini reflection tables without having to know the Flat\+Buffers or reflection encoding.

\doxysubsection*{Storing maps / dictionaries in a Flat\+Buffer}

Flat\+Buffers doesn\textquotesingle{}t support maps natively, but there is support to emulate their behavior with vectors and binary search, which means you can have fast lookups directly from a Flat\+Buffer without having to unpack your data into a {\ttfamily std\+::map} or similar.

To use it\+:
\begin{DoxyItemize}
\item Designate one of the fields in a table as they "{}key"{} field. You do this by setting the {\ttfamily key} attribute on this field, e.\+g. {\ttfamily name\+:string (key)}. You may only have one key field, and it must be of string or scalar type.
\item Write out tables of this type as usual, collect their offsets in an array or vector.
\item Instead of {\ttfamily Create\+Vector}, call {\ttfamily Create\+Vector\+Of\+Sorted\+Tables}, which will first sort all offsets such that the tables they refer to are sorted by the key field, then serialize it.
\item Now when you\textquotesingle{}re accessing the Flat\+Buffer, you can use {\ttfamily Vector\+::\+Lookup\+By\+Key} instead of just {\ttfamily Vector\+::\+Get} to access elements of the vector, e.\+g.\+: {\ttfamily myvector-\/\texorpdfstring{$>$}{>}Lookup\+By\+Key("{}\+Fred"{})}, which returns a pointer to the corresponding table type, or {\ttfamily nullptr} if not found. {\ttfamily Lookup\+By\+Key} performs a binary search, so should have a similar speed to {\ttfamily std\+::map}, though may be faster because of better caching. {\ttfamily Lookup\+By\+Key} only works if the vector has been sorted, it will likely not find elements if it hasn\textquotesingle{}t been sorted.
\end{DoxyItemize}

\doxysubsection*{Direct memory access}

As you can see from the above examples, all elements in a buffer are accessed through generated accessors. This is because everything is stored in little endian format on all platforms (the accessor performs a swap operation on big endian machines), and also because the layout of things is generally not known to the user.

For structs, layout is deterministic and guaranteed to be the same across platforms (scalars are aligned to their own size, and structs themselves to their largest member), and you are allowed to access this memory directly by using {\ttfamily sizeof()} and {\ttfamily memcpy} on the pointer to a struct, or even an array of structs.

To compute offsets to sub-\/elements of a struct, make sure they are a structs themselves, as then you can use the pointers to figure out the offset without having to hardcode it. This is handy for use of arrays of structs with calls like {\ttfamily gl\+Vertex\+Attrib\+Pointer} in Open\+GL or similar APIs.

It is important to note is that structs are still little endian on all machines, so only use tricks like this if you can guarantee you\textquotesingle{}re not shipping on a big endian machine (an {\ttfamily assert(\+FLATBUFFERS\+\_\+\+LITTLEENDIAN)} would be wise).

\doxysubsection*{Access of untrusted buffers}

The generated accessor functions access fields over offsets, which is very quick. These offsets are not verified at run-\/time, so a malformed buffer could cause a program to crash by accessing random memory.

When you\textquotesingle{}re processing large amounts of data from a source you know (e.\+g. your own generated data on disk), this is acceptable, but when reading data from the network that can potentially have been modified by an attacker, this is undesirable.

For this reason, you can optionally use a buffer verifier before you access the data. This verifier will check all offsets, all sizes of fields, and null termination of strings to ensure that when a buffer is accessed, all reads will end up inside the buffer.

Each root type will have a verification function generated for it, e.\+g. for {\ttfamily Monster}, you can call\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{bool}\ ok\ =\ \mbox{\hyperlink{namespaceMyGame_1_1Sample_a71cc64a209abe9c54ac37ca7e9ee99a8}{VerifyMonsterBuffer}}(\mbox{\hyperlink{namespaceflatbuffers_a3268477941df91db2eb06442b6e5f922}{Verifier}}(buf,\ len));}

\end{DoxyCode}


if {\ttfamily ok} is true, the buffer is safe to read.

Besides untrusted data, this function may be useful to call in debug mode, as extra insurance against data being corrupted somewhere along the way.

While verifying a buffer isn\textquotesingle{}t "{}free"{}, it is typically faster than a full traversal (since any scalar data is not actually touched), and since it may cause the buffer to be brought into cache before reading, the actual overhead may be even lower than expected.

In specialized cases where a denial of service attack is possible, the verifier has two additional constructor arguments that allow you to limit the nesting depth and total amount of tables the verifier may encounter before declaring the buffer malformed. The default is {\ttfamily Verifier(buf, len, 64 /\texorpdfstring{$\ast$}{*} max depth \texorpdfstring{$\ast$}{*}/, 1000000, /\texorpdfstring{$\ast$}{*} max tables \texorpdfstring{$\ast$}{*}/)} which should be sufficient for most uses.

\doxysubsection*{Text \& schema parsing}

Using binary buffers with the generated header provides a super low overhead use of Flat\+Buffer data. There are, however, times when you want to use text formats, for example because it interacts better with source control, or you want to give your users easy access to data.

Another reason might be that you already have a lot of data in JSON format, or a tool that generates JSON, and if you can write a schema for it, this will provide you an easy way to use that data directly.

(see the schema documentation for some specifics on the JSON format accepted).

Schema evolution compatibility for the JSON format follows the same rules as the binary format (JSON formatted data will be forwards/backwards compatible with schemas that evolve in a compatible way).

There are two ways to use text formats\+:

\doxyparagraph*{Using the compiler as a conversion tool}

This is the preferred path, as it doesn\textquotesingle{}t require you to add any new code to your program, and is maximally efficient since you can ship with binary data. The disadvantage is that it is an extra step for your users/developers to perform, though you might be able to automate it. \begin{DoxyVerb}flatc -b myschema.fbs mydata.json
\end{DoxyVerb}
 This will generate the binary file {\ttfamily mydata\+\_\+wire.\+bin} which can be loaded as before.

\doxyparagraph*{Making your program capable of loading text directly}

This gives you maximum flexibility. You could even opt to support both, i.\+e. check for both files, and regenerate the binary from text when required, otherwise just load the binary.

This option is currently only available for C++, or Java through JNI.

As mentioned in the section "{}\+Building"{} above, this technique requires you to link a few more files into your program, and you\textquotesingle{}ll want to include {\ttfamily \doxylink{idl_8h}{flatbuffers/idl.\+h}}.

Load text (either a schema or json) into an in-\/memory buffer (there is a convenient {\ttfamily Load\+File()} utility function in {\ttfamily \doxylink{util_8h}{flatbuffers/util.\+h}} if you wish). Construct a parser\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{classflatbuffers_1_1Parser}{flatbuffers::Parser}}\ \mbox{\hyperlink{namespaceclient_a76c71d249cc5b42de3ae3eb67742607a}{parser}};}

\end{DoxyCode}


Now you can parse any number of text files in sequence\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{namespaceclient_a76c71d249cc5b42de3ae3eb67742607a}{parser}}.Parse(text\_file.c\_str());}

\end{DoxyCode}


This works similarly to how the command-\/line compiler works\+: a sequence of files parsed by the same {\ttfamily Parser} object allow later files to reference definitions in earlier files. Typically this means you first load a schema file (which populates {\ttfamily Parser} with definitions), followed by one or more JSON files.

As optional argument to {\ttfamily Parse}, you may specify a null-\/terminated list of include paths. If not specified, any include statements try to resolve from the current directory.

If there were any parsing errors, {\ttfamily Parse} will return {\ttfamily false}, and {\ttfamily Parser\+::error\+\_\+} contains a human readable error string with a line number etc, which you should present to the creator of that file.

After each JSON file, the {\ttfamily Parser\+::fbb} member variable is the {\ttfamily \doxylink{classFlatBufferBuilder}{Flat\+Buffer\+Builder}} that contains the binary buffer version of that file, that you can access as described above.

{\ttfamily \doxylink{sample__text_8cpp}{samples/sample\+\_\+text.\+cpp}} is a code sample showing the above operations.

\doxysubsection*{Threading}

Reading a Flat\+Buffer does not touch any memory outside the original buffer, and is entirely read-\/only (all const), so is safe to access from multiple threads even without synchronisation primitives.

Creating a Flat\+Buffer is not thread safe. All state related to building a Flat\+Buffer is contained in a \doxylink{classFlatBufferBuilder}{Flat\+Buffer\+Builder} instance, and no memory outside of it is touched. To make this thread safe, either do not share instances of \doxylink{classFlatBufferBuilder}{Flat\+Buffer\+Builder} between threads (recommended), or manually wrap it in synchronisation primitives. There\textquotesingle{}s no automatic way to accomplish this, by design, as we feel multithreaded construction of a single buffer will be rare, and synchronisation overhead would be costly.

\doxysubsection*{Advanced union features}

The C++ implementation currently supports vectors of unions (i.\+e. you can declare a field as {\ttfamily \mbox{[}T\mbox{]}} where {\ttfamily T} is a union type instead of a table type). It also supports structs and strings in unions, besides tables.

For an example of these features, see {\ttfamily tests/union\+\_\+vector}, and {\ttfamily Union\+Vector\+Test} in {\ttfamily \doxylink{test_8cpp}{test.\+cpp}}.

Since these features haven\textquotesingle{}t been ported to other languages yet, if you choose to use them, you won\textquotesingle{}t be able to use these buffers in other languages ({\ttfamily flatc} will refuse to compile a schema that uses these features).

These features reduce the amount of "{}table wrapping"{} that was previously needed to use unions.

To use scalars, simply wrap them in a struct.

\doxysubsection*{Depth limit of nested objects and stack-\/overflow control}

The parser of Flatbuffers schema or json-\/files is kind of recursive parser. To avoid stack-\/overflow problem the parser has a built-\/in limiter of recursion depth. Number of nested declarations in a schema or number of nested json-\/objects is limited. By default, this depth limit set to {\ttfamily 64}. It is possible to override this limit with {\ttfamily FLATBUFFERS\+\_\+\+MAX\+\_\+\+PARSING\+\_\+\+DEPTH} definition. This definition can be helpful for testing purposes or embedded applications. For details see \doxysectlink{flatbuffers_guide_building}{build}{0} of CMake-\/based projects.\hypertarget{flatbuffers_guide_use_cpp_flatbuffers_locale_cpp}{}\doxysubsection{\texorpdfstring{Dependence from C-\/locale}{Dependence from C-locale}}\label{flatbuffers_guide_use_cpp_flatbuffers_locale_cpp}
The Flatbuffers \doxylink{namespaceflatbuffers}{flatbuffers} grammar "{}grammar"{} uses ASCII character set for identifiers, alphanumeric literals, reserved words.

Internal implementation of the Flatbuffers depends from functions which depend from C-\/locale\+: {\ttfamily strtod()} or {\ttfamily strtof()}, for example. The library expects the dot {\ttfamily .} symbol as the separator of an integer part from the fractional part of a float number. Another separator symbols ({\ttfamily ,} for example) will break the compatibility and may lead to an error while parsing a Flatbuffers schema or a json file.

The Standard C locale is a global resource, there is only one locale for the entire application. Some modern compilers and platforms have locale-\/independent or locale-\/narrow functions {\ttfamily strtof\+\_\+l}, {\ttfamily strtod\+\_\+l}, {\ttfamily strtoll\+\_\+l}, {\ttfamily strtoull\+\_\+l} to resolve this dependency. These functions use specified locale rather than the global or per-\/thread locale instead. They are part of POSIX-\/2008 but not part of the C/\+C++ standard library, therefore, may be missing on some platforms. The Flatbuffers library try to detect these functions at configuration and compile time\+:
\begin{DoxyItemize}
\item CMake {\ttfamily "{}\+CMake\+Lists.\+txt"{}}\+:
\begin{DoxyItemize}
\item Check existence of {\ttfamily strtol\+\_\+l} and {\ttfamily strtod\+\_\+l} in the {\ttfamily \texorpdfstring{$<$}{<}stdlib.\+h\texorpdfstring{$>$}{>}}.
\end{DoxyItemize}
\item Compile-\/time {\ttfamily "{}/include/base.\+h"{}}\+:
\begin{DoxyItemize}
\item {\ttfamily \+\_\+\+MSC\+\_\+\+VER \texorpdfstring{$>$}{>}= 1900}\+: MSVC2012 or higher if build with MSVC.
\item {\ttfamily \+\_\+\+XOPEN\+\_\+\+SOURCE\texorpdfstring{$>$}{>}=700}\+: POSIX-\/2008 if build with GCC/\+Clang.
\end{DoxyItemize}
\end{DoxyItemize}

After detection, the definition {\ttfamily FLATBUFFERS\+\_\+\+LOCALE\+\_\+\+INDEPENDENT} will be set to {\ttfamily 0} or {\ttfamily 1}. To override or stop this detection use CMake {\ttfamily -\/DFLATBUFFERS\+\_\+\+LOCALE\+\_\+\+INDEPENDENT=\{0\texorpdfstring{$\vert$}{|}1\}} or predefine {\ttfamily FLATBUFFERS\+\_\+\+LOCALE\+\_\+\+INDEPENDENT} symbol.

To test the compatibility of the Flatbuffers library with a specific locale use the environment variable {\ttfamily FLATBUFFERS\+\_\+\+TEST\+\_\+\+LOCALE}\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{>FLATBUFFERS\_TEST\_LOCALE="{}"{}\ ./flattests}
\DoxyCodeLine{>FLATBUFFERS\_TEST\_LOCALE="{}ru\_RU.CP1251"{}\ ./flattests}

\end{DoxyCode}


\doxysubsection*{Support of floating-\/point numbers}

The Flatbuffers library assumes that a C++ compiler and a CPU are compatible with the {\ttfamily IEEE-\/754} floating-\/point standard. The schema and json parser may fail if {\ttfamily fast-\/math} or {\ttfamily /fp\+:fast} mode is active.

\doxysubsubsection*{Support of hexadecimal and special floating-\/point numbers}

According to the \doxysectlink{flatbuffers_grammar}{grammar}{0} {\ttfamily fbs} and {\ttfamily json} files may use hexadecimal and special ({\ttfamily NaN}, {\ttfamily Inf}) floating-\/point literals. The Flatbuffers uses {\ttfamily strtof} and {\ttfamily strtod} functions to parse floating-\/point literals. The Flatbuffers library has a code to detect a compiler compatibility with the literals. If necessary conditions are met the preprocessor constant {\ttfamily FLATBUFFERS\+\_\+\+HAS\+\_\+\+NEW\+\_\+\+STRTOD} will be set to {\ttfamily 1}. The support of floating-\/point literals will be limited at compile time if {\ttfamily FLATBUFFERS\+\_\+\+HAS\+\_\+\+NEW\+\_\+\+STRTOD} constant is less than {\ttfamily 1}. In this case, schemas with hexadecimal or special literals cannot be used.

\doxysubsubsection*{Comparison of floating-\/point NaN values}

The floating-\/point {\ttfamily NaN} ({\ttfamily not a number}) is special value which representing an undefined or unrepresentable value. {\ttfamily NaN} may be explicitly assigned to variables, typically as a representation for missing values or may be a result of a mathematical operation. The {\ttfamily IEEE-\/754} defines two kind of {\ttfamily Na\+Ns}\+:
\begin{DoxyItemize}
\item Quiet Na\+Ns, or {\ttfamily q\+Na\+Ns}.
\item Signaling Na\+Ns, or {\ttfamily s\+Na\+Ns}.
\end{DoxyItemize}

According to the {\ttfamily IEEE-\/754}, a comparison with {\ttfamily NaN} always returns an unordered result even when compared with itself. As a result, a whole Flatbuffers object will be not equal to itself if has one or more {\ttfamily NaN}. Flatbuffers scalar fields that have the default value are not actually stored in the serialized data but are generated in code (see \doxysectlink{flatbuffers_guide_writing_schema}{Writing a schema}{0}). Scalar fields with {\ttfamily NaN} defaults break this behavior. If a schema has a lot of {\ttfamily NaN} defaults the Flatbuffers can override the unordered comparison by the ordered\+: {\ttfamily (NaN==NaN)-\/\texorpdfstring{$>$}{>}true}. This ordered comparison is enabled when compiling a program with the symbol {\ttfamily FLATBUFFERS\+\_\+\+NAN\+\_\+\+DEFAULTS} defined. Additional computations added by {\ttfamily FLATBUFFERS\+\_\+\+NAN\+\_\+\+DEFAULTS} are very cheap if GCC or Clang used. These compilers have a compile-\/time implementation of {\ttfamily isnan} checking which MSVC does not.

~\newline
 