<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Demo Project: Annotating FlatBuffers</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Demo Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Annotating FlatBuffers</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This provides a way to annotate flatbuffer binary data, byte-by-byte, with a schema. It is useful for development purposes and understanding the details of the internal format.</p>
<h1>Annotating</h1>
<p>Given a <code>schema</code>, as either a plain-text (<code>.fbs</code>) or a binary schema (<code>.bfbs</code>), and <code>binary</code> file(s) that were created by the <code>schema</code>. You can annotate them using:</p>
<div class="fragment"><div class="line">flatc --annotate SCHEMA -- BINARY_FILES...</div>
</div><!-- fragment --><p>This will produce a set of annotated files (<code>.afb</code> Annotated FlatBuffer) corresponding to the input binary files.</p>
<h2>Example</h2>
<p>Taken from the <a href="https://github.com/google/flatbuffers/tree/master/tests/annotated_binary">tests/annotated_binary</a>.</p>
<div class="fragment"><div class="line">cd tests/annotated_binary</div>
<div class="line">../../flatc --annotate annotated_binary.fbs -- annotated_binary.bin</div>
</div><!-- fragment --><p>Which will produce a <code>annotated_binary.afb</code> file in the current directory.</p>
<p>!!! Tip </p><pre class="fragment">The `annotated_binary.bin` is the flatbufer binary of the data contained
within `annotated_binary.json`, which was made by the following command:

```sh
..\..\flatc -b annotated_binary.fbs annotated_binary.json
```
</pre> <h1>.afb Text Format</h1>
<p>Currently there is a built-in text-based format for outputting the annotations. A full example is shown here: <a href="https://github.com/google/flatbuffers/blob/master/tests/annotated_binary/annotated_binary.afb"><code>annotated_binary.afb</code></a></p>
<p>The data is organized as a table with fixed columns grouped into Binary sections and regions, starting from the beginning of the binary (offset <code>0</code>).</p>
<h2>Columns</h2>
<p>The columns are as follows:</p>
<ol type="1">
<li><p class="startli">The offset from the start of the binary, expressed in hexadecimal format (e.g. <code>+0x003c</code>).</p>
<p class="startli">The prefix <code>+</code> is added to make searching for the offset (compared to some random value) a bit easier.</p>
</li>
<li><p class="startli">The raw binary data, expressed in hexadecimal format.</p>
<p class="startli">This is in the little endian format the buffer uses internally and what you would see with a normal binary text viewer.</p>
</li>
<li><p class="startli">The type of the data.</p>
<p class="startli">This may be the type specified in the schema or some internally defined types:</p>
</li>
</ol>
<pre class="fragment">| Internal Type | Purpose                                            |
|---------------|----------------------------------------------------|
| `VOffset16`   | Virtual table offset, relative to the table offset |
| `UOffset32`   | Unsigned offset, relative to the current offset    |
| `SOffset32`   | Signed offset, relative to the current offset      |
</pre><ol type="1">
<li><p class="startli">The value of the data.</p>
<p class="startli">This is shown in big endian format that is generally written for humans to consume (e.g. <code>0x0013</code>). As well as the "casted" value (e.g. <code>0x0013</code>is <code>19</code> in decimal) in parentheses.</p>
</li>
<li><p class="startli">Notes about the particular data.</p>
<p class="startli">This describes what the data is about, either some internal usage, or tied to the schema.</p>
</li>
</ol>
<h2>Binary Sections</h2>
<p>The file is broken up into Binary Sections, which are comprised of contiguous binary regions that are logically grouped together. For example, a binary section may be a single instance of a flatbuffer <code>Table</code> or its <code>vtable</code>. The sections may be labelled with the name of the associated type, as defined in the input schema.</p>
<p>An example of a <code>vtable</code> Binary Section that is associated with the user-defined <code>AnnotateBinary.Bar</code> table.</p>
<div class="fragment"><div class="line">vtable (AnnotatedBinary.Bar):</div>
<div class="line">  +0x00A0 | 08 00      | uint16_t   | 0x0008 (8)   | size of this vtable</div>
<div class="line">  +0x00A2 | 13 00      | uint16_t   | 0x0013 (19)  | size of referring table</div>
<div class="line">  +0x00A4 | 08 00      | VOffset16  | 0x0008 (8)   | offset to field `a` (id: 0)</div>
<div class="line">  +0x00A6 | 04 00      | VOffset16  | 0x0004 (4)   | offset to field `b` (id: 1)</div>
</div><!-- fragment --><p>These are purely annotative, there is no embedded information about these regions in the flatbuffer itself.</p>
<h2>Binary Regions</h2>
<p>Binary regions are contiguous bytes regions that are grouped together to form some sort of value, e.g. a <code>scalar</code> or an array of scalars. A binary region may be split up over multiple text lines, if the size of the region is large.</p>
<h3>Annotation Example</h3>
<p>Looking at an example binary region:</p>
<div class="fragment"><div class="line">vtable (AnnotatedBinary.Bar):</div>
<div class="line">  +0x00A0 | 08 00      | uint16_t   | 0x0008 (8)   | size of this vtable</div>
</div><!-- fragment --><p>The first column (<code>+0x00A0</code>) is the offset to this region from the beginning of the buffer.</p>
<p>The second column are the raw bytes (hexadecimal) that make up this region. These are expressed in the little-endian format that flatbuffers uses for the wire format.</p>
<p>The third column is the type to interpret the bytes as. For the above example, the type is <code>uint16_t</code> which is a 16-bit unsigned integer type.</p>
<p>The fourth column shows the raw bytes as a compacted, big-endian value. The raw bytes are duplicated in this fashion since it is more intuitive to read the data in the big-endian format (e.g., <code>0x0008</code>). This value is followed by the decimal representation of the value (e.g., <code>(8)</code>). For strings, the raw string value is shown instead.</p>
<p>The fifth column is a textual comment on what the value is. As much metadata as known is provided.</p>
<h2>Offsets</h2>
<p>If the type in the 3rd column is of an absolute offset (<code>SOffet32</code> or <code>Offset32</code>), the fourth column also shows an <code>Loc: +0x025A</code> value which shows where in the binary this region is pointing to. These values are absolute from the beginning of the file, their calculation from the raw value in the 4th column depends on the context. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
