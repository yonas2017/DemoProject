// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_CLIENTMESSAGE_H_
#define FLATBUFFERS_GENERATED_CLIENTMESSAGE_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
                  FLATBUFFERS_VERSION_MINOR == 12 &&
                  FLATBUFFERS_VERSION_REVISION == 23,
              "Non-compatible flatbuffers version included");

struct client_message_t;
struct client_message_tBuilder;

enum ClientMessageType
{
    GET_JOB = 0,
    NORMAL_TERMINATOIN = 1,
    FAIL_TERMINATION = 2,
    QUIT_PROGRAM = 3
};

inline const ClientMessageType (&EnumValuesClientMessageType())[4]
{
    static const ClientMessageType values[] = {GET_JOB, NORMAL_TERMINATOIN,
                                               FAIL_TERMINATION, QUIT_PROGRAM};
    return values;
}

inline const char *const *EnumNamesClientMessageType()
{
    static const char *const names[5] = {"GET_JOB", "NORMAL_TERMINATOIN",
                                         "FAIL_TERMINATION", "QUIT_PROGRAM",
                                         nullptr};
    return names;
}

inline const char *EnumNameClientMessageType(ClientMessageType e)
{
    if (::flatbuffers::IsOutRange(e, GET_JOB, QUIT_PROGRAM)) return "";
    const size_t index = static_cast<size_t>(e);
    return EnumNamesClientMessageType()[index];
}

struct client_message_t FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table
{
    typedef client_message_tBuilder Builder;
    enum FlatBuffersVTableOffset    FLATBUFFERS_VTABLE_UNDERLYING_TYPE
    {
        VT_MSG_TYPE = 4,
        VT_ALL_JOBS = 6,
        VT_NUM_JOBS = 8
    };
    ClientMessageType msg_type() const
    {
        return static_cast<ClientMessageType>(
            GetField<uint8_t>(VT_MSG_TYPE, 0));
    }
    bool mutate_msg_type(
        ClientMessageType _msg_type = static_cast<ClientMessageType>(0))
    {
        return SetField<uint8_t>(VT_MSG_TYPE, static_cast<uint8_t>(_msg_type),
                                 0);
    }
    bool all_jobs() const { return GetField<uint8_t>(VT_ALL_JOBS, 0) != 0; }
    bool mutate_all_jobs(bool _all_jobs = 0)
    {
        return SetField<uint8_t>(VT_ALL_JOBS, static_cast<uint8_t>(_all_jobs),
                                 0);
    }
    uint16_t num_jobs() const { return GetField<uint16_t>(VT_NUM_JOBS, 0); }
    bool     mutate_num_jobs(uint16_t _num_jobs = 0)
    {
        return SetField<uint16_t>(VT_NUM_JOBS, _num_jobs, 0);
    }
    bool Verify(::flatbuffers::Verifier &verifier) const
    {
        return VerifyTableStart(verifier) &&
               VerifyField<uint8_t>(verifier, VT_MSG_TYPE, 1) &&
               VerifyField<uint8_t>(verifier, VT_ALL_JOBS, 1) &&
               VerifyField<uint16_t>(verifier, VT_NUM_JOBS, 2) &&
               verifier.EndTable();
    }
};

struct client_message_tBuilder
{
    typedef client_message_t          Table;
    ::flatbuffers::FlatBufferBuilder &fbb_;
    ::flatbuffers::uoffset_t          start_;
    void                              add_msg_type(ClientMessageType msg_type)
    {
        fbb_.AddElement<uint8_t>(client_message_t::VT_MSG_TYPE,
                                 static_cast<uint8_t>(msg_type), 0);
    }
    void add_all_jobs(bool all_jobs)
    {
        fbb_.AddElement<uint8_t>(client_message_t::VT_ALL_JOBS,
                                 static_cast<uint8_t>(all_jobs), 0);
    }
    void add_num_jobs(uint16_t num_jobs)
    {
        fbb_.AddElement<uint16_t>(client_message_t::VT_NUM_JOBS, num_jobs, 0);
    }
    explicit client_message_tBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb)
    {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<client_message_t> Finish()
    {
        const auto end = fbb_.EndTable(start_);
        auto       o = ::flatbuffers::Offset<client_message_t>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<client_message_t> Createclient_message_t(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ClientMessageType msg_type = GET_JOB, bool all_jobs = false,
    uint16_t num_jobs = 0)
{
    client_message_tBuilder builder_(_fbb);
    builder_.add_num_jobs(num_jobs);
    builder_.add_all_jobs(all_jobs);
    builder_.add_msg_type(msg_type);
    return builder_.Finish();
}

inline const client_message_t *Getclient_message_t(const void *buf)
{
    return ::flatbuffers::GetRoot<client_message_t>(buf);
}

inline const client_message_t *GetSizePrefixedclient_message_t(const void *buf)
{
    return ::flatbuffers::GetSizePrefixedRoot<client_message_t>(buf);
}

inline client_message_t *GetMutableclient_message_t(void *buf)
{
    return ::flatbuffers::GetMutableRoot<client_message_t>(buf);
}

inline client_message_t *GetMutableSizePrefixedclient_message_t(void *buf)
{
    return ::flatbuffers::GetMutableSizePrefixedRoot<client_message_t>(buf);
}

inline bool Verifyclient_message_tBuffer(::flatbuffers::Verifier &verifier)
{
    return verifier.VerifyBuffer<client_message_t>(nullptr);
}

inline bool VerifySizePrefixedclient_message_tBuffer(
    ::flatbuffers::Verifier &verifier)
{
    return verifier.VerifySizePrefixedBuffer<client_message_t>(nullptr);
}

inline void Finishclient_message_tBuffer(
    ::flatbuffers::FlatBufferBuilder &      fbb,
    ::flatbuffers::Offset<client_message_t> root)
{
    fbb.Finish(root);
}

inline void FinishSizePrefixedclient_message_tBuffer(
    ::flatbuffers::FlatBufferBuilder &      fbb,
    ::flatbuffers::Offset<client_message_t> root)
{
    fbb.FinishSizePrefixed(root);
}

#endif  // FLATBUFFERS_GENERATED_CLIENTMESSAGE_H_
