<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Demo Project: FlatBuffer Internals</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Demo Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">FlatBuffer Internals</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This section is entirely optional for the use of FlatBuffers. In normal usage, you should never need the information contained herein. If you're interested however, it should give you more of an appreciation of why FlatBuffers is both efficient and convenient.</p>
<h2>Format components</h2>
<p>A FlatBuffer is a binary file and in-memory format consisting mostly of scalars of various sizes, all aligned to their own size. Each scalar is also always represented in little-endian format, as this corresponds to all commonly used CPUs today. FlatBuffers will also work on big-endian machines, but will be slightly slower because of additional byte-swap intrinsics.</p>
<p>It is assumed that the following conditions are met, to ensure cross-platform interoperability:</p><ul>
<li>The binary <code>IEEE-754</code> format is used for floating-point numbers.</li>
<li>The <code>two's complemented</code> representation is used for signed integers.</li>
<li>The endianness is the same for floating-point numbers as for integers.</li>
</ul>
<p>On purpose, the format leaves a lot of details about where exactly things live in memory undefined, e.g. fields in a table can have any order, and objects to some extent can be stored in many orders. This is because the format doesn't need this information to be efficient, and it leaves room for optimization and extension (for example, fields can be packed in a way that is most compact). Instead, the format is defined in terms of offsets and adjacency only. This may mean two different implementations may produce different binaries given the same input values, and this is perfectly valid.</p>
<h2>Format identification</h2>
<p>The format also doesn't contain information for format identification and versioning, which is also by design. FlatBuffers is a statically typed system, meaning the user of a buffer needs to know what kind of buffer it is. FlatBuffers can of course be wrapped inside other containers where needed, or you can use its union feature to dynamically identify multiple possible sub-objects stored. Additionally, it can be used together with the schema parser if full reflective capabilities are desired.</p>
<p>Versioning is something that is intrinsically part of the format (the optionality / extensibility of fields), so the format itself does not need a version number (it's a meta-format, in a sense). We're hoping that this format can accommodate all data needed. If format breaking changes are ever necessary, it would become a new kind of format rather than just a variation.</p>
<h2>Offsets</h2>
<p>The most important and generic offset type (see <code><a class="el" href="flatbuffers_8h.html">flatbuffers.h</a></code>) is <code>uoffset_t</code>, which is currently always a <code>uint32_t</code>, and is used to refer to all tables/unions/strings/vectors (these are never stored in-line). 32bit is intentional, since we want to keep the format binary compatible between 32 and 64bit systems, and a 64bit offset would bloat the size for almost all uses. A version of this format with 64bit (or 16bit) offsets is easy to set when needed. Unsigned means they can only point in one direction, which typically is forward (towards a higher memory location). Any backwards offsets will be explicitly marked as such.</p>
<p>The format starts with an <code>uoffset_t</code> to the root table in the buffer.</p>
<p>We have two kinds of objects, structs and tables.</p>
<h2>Structs</h2>
<p>These are the simplest, and as mentioned, intended for simple data that benefits from being extra efficient and doesn't need versioning / extensibility. They are always stored inline in their parent (a struct, table, or vector) for maximum compactness. Structs define a consistent memory layout where all components are aligned to their size, and structs aligned to their largest scalar member. This is done independent of the alignment rules of the underlying compiler to guarantee a cross platform compatible layout. This layout is then enforced in the generated code.</p>
<h2>Tables</h2>
<p>Unlike structs, these are not stored in inline in their parent, but are referred to by offset.</p>
<p>They start with an <code>soffset_t</code> to a vtable. This is a signed version of <code>uoffset_t</code>, since vtables may be stored anywhere relative to the object. This offset is subtracted (not added) from the object start to arrive at the vtable start. This offset is followed by all the fields as aligned scalars (or offsets). Unlike structs, not all fields need to be present. There is no set order and layout. A table may contain field offsets that point to the same value if the user explicitly serializes the same offset twice.</p>
<p>To be able to access fields regardless of these uncertainties, we go through a vtable of offsets. Vtables are shared between any objects that happen to have the same vtable values.</p>
<p>The elements of a vtable are all of type <code>voffset_t</code>, which is a <code>uint16_t</code>. The first element is the size of the vtable in bytes, including the size element. The second one is the size of the object, in bytes (including the vtable offset). This size could be used for streaming, to know how many bytes to read to be able to access all <em>inline</em> fields of the object. The remaining elements are the N offsets, where N is the amount of fields declared in the schema when the code that constructed this buffer was compiled (thus, the size of the table is N + 2).</p>
<p>All accessor functions in the generated code for tables contain the offset into this table as a constant. This offset is checked against the first field (the number of elements), to protect against newer code reading older data. If this offset is out of range, or the vtable entry is 0, that means the field is not present in this object, and the default value is return. Otherwise, the entry is used as offset to the field to be read.</p>
<h2>Unions</h2>
<p>Unions are encoded as the combination of two fields: an enum representing the union choice and the offset to the actual element. FlatBuffers reserves the enumeration constant <code>NONE</code> (encoded as 0) to mean that the union field is not set.</p>
<h2>Strings and Vectors</h2>
<p>Strings are simply a vector of bytes, and are always null-terminated. Vectors are stored as contiguous aligned scalar elements prefixed by a 32bit element count (not including any null termination). Neither is stored inline in their parent, but are referred to by offset. A vector may consist of more than one offset pointing to the same value if the user explicitly serializes the same offset twice.</p>
<h2>Construction</h2>
<p>The current implementation constructs these buffers backwards (starting at the highest memory address of the buffer), since that significantly reduces the amount of bookkeeping and simplifies the construction API.</p>
<h2>Code example</h2>
<p>Here's an example of the code that gets generated for the <code>samples/monster.fbs</code>. What follows is the entire file, broken up by comments: </p><pre class="fragment">// automatically generated, do not modify

#include "flatbuffers/flatbuffers.h"

namespace MyGame {
namespace Sample {
</pre><p> Nested namespace support. </p><pre class="fragment">enum {
  Color_Red = 0,
  Color_Green = 1,
  Color_Blue = 2,
};

inline const char **EnumNamesColor() {
  static const char *names[] = { "Red", "Green", "Blue", nullptr };
  return names;
}

inline const char *EnumNameColor(int e) { return EnumNamesColor()[e]; }
</pre><p> Enums and convenient reverse lookup. </p><pre class="fragment">enum {
  Any_NONE = 0,
  Any_Monster = 1,
};

inline const char **EnumNamesAny() {
  static const char *names[] = { "NONE", "Monster", nullptr };
  return names;
}

inline const char *EnumNameAny(int e) { return EnumNamesAny()[e]; }
</pre><p> Unions share a lot with enums. </p><pre class="fragment">struct Vec3;
struct Monster;
</pre><p> Predeclare all data types since circular references between types are allowed (circular references between object are not, though). </p><pre class="fragment">FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec3 {
 private:
  float x_;
  float y_;
  float z_;

 public:
  Vec3(float x, float y, float z)
    : x_(flatbuffers::EndianScalar(x)), y_(flatbuffers::EndianScalar(y)), z_(flatbuffers::EndianScalar(z)) {}

  float x() const { return flatbuffers::EndianScalar(x_); }
  float y() const { return flatbuffers::EndianScalar(y_); }
  float z() const { return flatbuffers::EndianScalar(z_); }
};
FLATBUFFERS_STRUCT_END(Vec3, 12);
</pre><p> These ugly macros do a couple of things: they turn off any padding the compiler might normally do, since we add padding manually (though none in this example), and they enforce alignment chosen by FlatBuffers. This ensures the layout of this struct will look the same regardless of compiler and platform. Note that the fields are private: this is because these store little endian scalars regardless of platform (since this is part of the serialized data). <code>EndianScalar</code> then converts back and forth, which is a no-op on all current mobile and desktop platforms, and a single machine instruction on the few remaining big endian platforms. </p><pre class="fragment">struct Monster : private flatbuffers::Table {
  const Vec3 *pos() const { return GetStruct&lt;const Vec3 *&gt;(4); }
  int16_t mana() const { return GetField&lt;int16_t&gt;(6, 150); }
  int16_t hp() const { return GetField&lt;int16_t&gt;(8, 100); }
  const flatbuffers::String *name() const { return GetPointer&lt;const flatbuffers::String *&gt;(10); }
  const flatbuffers::Vector&lt;uint8_t&gt; *inventory() const { return GetPointer&lt;const flatbuffers::Vector&lt;uint8_t&gt; *&gt;(14); }
  int8_t color() const { return GetField&lt;int8_t&gt;(16, 2); }
};
</pre><p> Tables are a bit more complicated. A table accessor struct is used to point at the serialized data for a table, which always starts with an offset to its vtable. It derives from <code>Table</code>, which contains the <code>GetField</code> helper functions. GetField takes a vtable offset, and a default value. It will look in the vtable at that offset. If the offset is out of bounds (data from an older version) or the vtable entry is 0, the field is not present and the default is returned. Otherwise, it uses the entry as an offset into the table to locate the field. </p><pre class="fragment">struct MonsterBuilder {
  flatbuffers::FlatBufferBuilder &amp;fbb_;
  flatbuffers::uoffset_t start_;
  void add_pos(const Vec3 *pos) { fbb_.AddStruct(4, pos); }
  void add_mana(int16_t mana) { fbb_.AddElement&lt;int16_t&gt;(6, mana, 150); }
  void add_hp(int16_t hp) { fbb_.AddElement&lt;int16_t&gt;(8, hp, 100); }
  void add_name(flatbuffers::Offset&lt;flatbuffers::String&gt; name) { fbb_.AddOffset(10, name); }
  void add_inventory(flatbuffers::Offset&lt;flatbuffers::Vector&lt;uint8_t&gt;&gt; inventory) { fbb_.AddOffset(14, inventory); }
  void add_color(int8_t color) { fbb_.AddElement&lt;int8_t&gt;(16, color, 2); }
  MonsterBuilder(flatbuffers::FlatBufferBuilder &amp;_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  flatbuffers::Offset&lt;Monster&gt; Finish() { return flatbuffers::Offset&lt;Monster&gt;(fbb_.EndTable(start_, 7)); }
};
</pre><p> <code>MonsterBuilder</code> is the base helper struct to construct a table using a <code><a class="el" href="classFlatBufferBuilder.html" title="Helper class to hold data needed in creation of a FlatBuffer. To serialize data, you typically call o...">FlatBufferBuilder</a></code>. You can add the fields in any order, and the <code>Finish</code> call will ensure the correct vtable gets generated. </p><pre class="fragment">inline flatbuffers::Offset&lt;Monster&gt; CreateMonster(flatbuffers::FlatBufferBuilder &amp;_fbb,
                                                  const Vec3 *pos, int16_t mana,
                                                  int16_t hp,
                                                  flatbuffers::Offset&lt;flatbuffers::String&gt; name,
                                                  flatbuffers::Offset&lt;flatbuffers::Vector&lt;uint8_t&gt;&gt; inventory,
                                                  int8_t color) {
  MonsterBuilder builder_(_fbb);
  builder_.add_inventory(inventory);
  builder_.add_name(name);
  builder_.add_pos(pos);
  builder_.add_hp(hp);
  builder_.add_mana(mana);
  builder_.add_color(color);
  return builder_.Finish();
}
</pre><p> <code>CreateMonster</code> is a convenience function that calls all functions in <code>MonsterBuilder</code> above for you. Note that if you pass values which are defaults as arguments, it will not actually construct that field, so you can probably use this function instead of the builder class in almost all cases. </p><pre class="fragment">inline const Monster *GetMonster(const void *buf) { return flatbuffers::GetRoot&lt;Monster&gt;(buf); }
</pre><p> This function is only generated for the root table type, to be able to start traversing a FlatBuffer from a raw buffer pointer. </p><pre class="fragment">}; // namespace MyGame
}; // namespace Sample
</pre> <h2>Encoding example.</h2>
<p>Below is a sample encoding for the following JSON corresponding to the above schema: </p><pre class="fragment">{ pos: { x: 1, y: 2, z: 3 }, name: "fred", hp: 50 }
</pre><p> Resulting in this binary buffer: </p><pre class="fragment">// Start of the buffer:
uint32_t 20  // Offset to the root table.

// Start of the vtable. Not shared in this example, but could be:
uint16_t 16 // Size of table, starting from here.
uint16_t 22 // Size of object inline data.
uint16_t 4, 0, 20, 16, 0, 0  // Offsets to fields from start of (root) table, 0 for not present.

// Start of the root table:
int32_t 16     // Offset to vtable used (default negative direction)
float 1, 2, 3  // the Vec3 struct, inline.
uint32_t 8     // Offset to the name string.
int16_t 50     // hp field.
int16_t 0      // Padding for alignment.

// Start of name string:
uint32_t 4  // Length of string.
int8_t 'f', 'r', 'e', 'd', 0, 0, 0, 0  // Text + 0 termination + padding.
</pre><p> Note that this not the only possible encoding, since the writer has some flexibility in which of the children of root object to write first (though in this case there's only one string), and what order to write the fields in. Different orders may also cause different alignments to happen.</p>
<h2>Additional reading.</h2>
<p>The author of the C language implementation has made a similar <a href="https://github.com/dvidelabs/flatcc/blob/master/doc/binary-format.md#flatbuffers-binary-format">document</a> that may further help clarify the format.</p>
<h1>FlexBuffers</h1>
<p>The <a class="el" href="flexbuffers.html">schema-less</a> version of FlatBuffers have their own encoding, detailed here.</p>
<p>It shares many properties mentioned above, in that all data is accessed over offsets, all scalars are aligned to their own size, and all data is always stored in little endian format.</p>
<p>One difference is that FlexBuffers are built front to back, so children are stored before parents, and the root of the data starts at the last byte.</p>
<p>Another difference is that scalar data is stored with a variable number of bits (8/16/32/64). The current width is always determined by the <em>parent</em>, i.e. if the scalar sits in a vector, the vector determines the bit width for all elements at once. Selecting the minimum bit width for a particular vector is something the encoder does automatically and thus is typically of no concern to the user, though being aware of this feature (and not sticking a double in the same vector as a bunch of byte sized elements) is helpful for efficiency.</p>
<p>Unlike FlatBuffers there is only one kind of offset, and that is an unsigned integer indicating the number of bytes in a negative direction from the address of itself (where the offset is stored).</p>
<h3>Vectors</h3>
<p>The representation of the vector is at the core of how FlexBuffers works (since maps are really just a combination of 2 vectors), so it is worth starting there.</p>
<p>As mentioned, a vector is governed by a single bit width (supplied by its parent). This includes the size field. For example, a vector that stores the integer values <code>1, 2, 3</code> is encoded as follows: </p><pre class="fragment">uint8_t 3, 1, 2, 3, 4, 4, 4
</pre><p> The first <code>3</code> is the size field, and is placed before the vector (an offset from the parent to this vector points to the first element, not the size field, so the size field is effectively at index -1). Since this is an untyped vector <code>SL_VECTOR</code>, it is followed by 3 type bytes (one per element of the vector), which are always following the vector, and are always a uint8_t even if the vector is made up of bigger scalars.</p>
<p>A vector may include more than one offset pointing to the same value if the user explicitly serializes the same offset twice.</p>
<h3>Types</h3>
<p>A type byte is made up of 2 components (see <a class="el" href="flexbuffers_8h.html">flexbuffers.h</a> for exact values):</p>
<ul>
<li>2 lower bits representing the bit-width of the child (8, 16, 32, 64). This is only used if the child is accessed over an offset, such as a child vector. It is ignored for inline types.</li>
<li>6 bits representing the actual type (see <a class="el" href="flexbuffers_8h.html">flexbuffers.h</a>).</li>
</ul>
<p>Thus, in this example <code>4</code> means 8 bit child (value 0, unused, since the value is in-line), type <code>SL_INT</code> (value 1).</p>
<h3>Typed Vectors</h3>
<p>These are like the Vectors above, but omit the type bytes. The type is instead determined by the vector type supplied by the parent. Typed vectors are only available for a subset of types for which these savings can be significant, namely inline signed/unsigned integers (<code>TYPE_VECTOR_INT</code> / <code>TYPE_VECTOR_UINT</code>), floats (<code>TYPE_VECTOR_FLOAT</code>), and keys (<code>TYPE_VECTOR_KEY</code>, see below).</p>
<p>Additionally, for scalars, there are fixed length vectors of sizes 2 / 3 / 4 that don't store the size (<code>TYPE_VECTOR_INT2</code> etc.), for an additional savings in space when storing common vector or color data.</p>
<h3>Scalars</h3>
<p>FlexBuffers supports integers (<code>TYPE_INT</code> and <code>TYPE_UINT</code>) and floats (<code>TYPE_FLOAT</code>), available in the bit-widths mentioned above. They can be stored both inline and over an offset (<code>TYPE_INDIRECT_*</code>).</p>
<p>The offset version is useful to encode costly 64bit (or even 32bit) quantities into vectors / maps of smaller sizes, and to share / repeat a value multiple times.</p>
<h3>Booleans and Nulls</h3>
<p>Booleans (<code>TYPE_BOOL</code>) and nulls (<code>TYPE_NULL</code>) are encoded as inlined unsigned integers.</p>
<h3>Blobs, Strings and Keys.</h3>
<p>A blob (<code>TYPE_BLOB</code>) is encoded similar to a vector, with one difference: the elements are always <code>uint8_t</code>. The parent bit width only determines the width of the size field, allowing blobs to be large without the elements being large.</p>
<p>Strings (<code>TYPE_STRING</code>) are similar to blobs, except they have an additional 0 termination byte for convenience, and they MUST be UTF-8 encoded (since an accessor in a language that does not support pointers to UTF-8 data may have to convert them to a native string type).</p>
<p>A "Key" (<code>TYPE_KEY</code>) is similar to a string, but doesn't store the size field. They're so named because they are used with maps, which don't care for the size, and can thus be even more compact. Unlike strings, keys cannot contain bytes of value 0 as part of their data (size can only be determined by <code>strlen</code>), so while you can use them outside the context of maps if you so desire, you're usually better off with strings.</p>
<h3>Maps</h3>
<p>A map (<code>TYPE_MAP</code>) is like an (untyped) vector, but with 2 prefixes before the size field:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadRight">index   </th><th class="markdownTableHeadLeft">field    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">-3   </td><td class="markdownTableBodyLeft">An offset to the keys vector (may be shared between tables).    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">-2   </td><td class="markdownTableBodyLeft">Byte width of the keys vector.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">-1   </td><td class="markdownTableBodyLeft">Size (from here on it is compatible with <code>TYPE_VECTOR</code>)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyRight">0   </td><td class="markdownTableBodyLeft">Elements.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyRight">Size   </td><td class="markdownTableBodyLeft">Types.   </td></tr>
</table>
<p>Since a map is otherwise the same as a vector, it can be iterated like a vector (which is probably faster than lookup by key).</p>
<p>The keys vector is a typed vector of keys. Both the keys and corresponding values <em>have</em> to be stored in sorted order (as determined by <code>strcmp</code>), such that lookups can be made using binary search.</p>
<p>The reason the key vector is a separate structure from the value vector is such that it can be shared between multiple value vectors, and also to allow it to be treated as its own individual vector in code.</p>
<p>An example map { foo: 13, bar: 14 } would be encoded as: </p><pre class="fragment">0 : uint8_t 'b', 'a', 'r', 0
4 : uint8_t 'f', 'o', 'o', 0
8 : uint8_t 2      // key vector of size 2
// key vector offset points here
9 : uint8_t 9, 6   // offsets to bar_key and foo_key
11: uint8_t 2, 1   // offset to key vector, and its byte width
13: uint8_t 2      // value vector of size
// value vector offset points here
14: uint8_t 14, 13 // values
16: uint8_t 4, 4   // types
</pre> <h3>The root</h3>
<p>As mentioned, the root starts at the end of the buffer. The last uint8_t is the width in bytes of the root (normally the parent determines the width, but the root has no parent). The uint8_t before this is the type of the root, and the bytes before that are the root value (of the number of bytes specified by the last byte).</p>
<p>So for example, the integer value <code>13</code> as root would be: </p><pre class="fragment">uint8_t 13, 4, 1    // Value, type, root byte width.
</pre><p><br  />
 </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
