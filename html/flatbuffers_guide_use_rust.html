<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Demo Project: Use in Rust</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Demo Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Use in Rust</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1>Before you get started</h1>
<p>Before diving into the FlatBuffers usage in Rust, it should be noted that the <a class="el" href="flatbuffers_guide_tutorial.html">Tutorial</a> page has a complete guide to general FlatBuffers usage in all of the supported languages (including Rust). This page is designed to cover the nuances of FlatBuffers usage, specific to Rust.</p>
<h3>Prerequisites</h3>
<p>This page assumes you have written a FlatBuffers schema and compiled it with the Schema Compiler. If you have not, please see <a class="el" href="flatbuffers_guide_using_schema_compiler.html">Using the schema compiler</a> and <a class="el" href="flatbuffers_guide_writing_schema.html">Writing a schema</a>.</p>
<p>Assuming you wrote a schema, say <code>mygame.fbs</code> (though the extension doesn't matter), you've generated a Rust file called <code>mygame_generated.rs</code> using the compiler (e.g. <code>flatc --rust mygame.fbs</code> or via helpers listed in "Useful
tools created by others" section bellow), you can now start using this in your program by including the file. As noted, this header relies on the crate <code>flatbuffers</code>, which should be in your include <code>Cargo.toml</code>.</p>
<h1>FlatBuffers Rust library code location</h1>
<p>The code for the FlatBuffers Rust library can be found at <code>flatbuffers/rust</code>. You can browse the library code on the <a href="https://github.com/google/flatbuffers/tree/master/rust">FlatBuffers GitHub page</a>.</p>
<h1>Testing the FlatBuffers Rust library</h1>
<p>The code to test the Rust library can be found at <code>flatbuffers/tests/rust_usage_test</code>. The test code itself is located in <a href="https://github.com/google/flatbuffers/blob/master/tests/rust_usage_test/tests/integration_test.rs">integration_test.rs</a></p>
<p>This test file requires <code>flatc</code> to be present. To review how to build the project, please read the <a class="el" href="flatbuffers_guide_building.html">Building</a> documentation.</p>
<p>To run the tests, execute <code>RustTest.sh</code> from the <code>flatbuffers/tests</code> directory. For example, on <a href="https://en.wikipedia.org/wiki/Linux">Linux</a>, you would simply run: <code>cd tests &amp;&amp; ./RustTest.sh</code>.</p>
<p><em>Note: The shell script requires <a href="https://www.rust-lang.org">Rust</a> to be installed.</em></p>
<h1>Using the FlatBuffers Rust library</h1>
<p><em>Note: See <a class="el" href="flatbuffers_guide_tutorial.html">Tutorial</a> for a more in-depth example of how to use FlatBuffers in Rust.</em></p>
<p>FlatBuffers supports both reading and writing FlatBuffers in Rust.</p>
<p>To use FlatBuffers in your code, first generate the Rust modules from your schema with the <code>--rust</code> option to <code>flatc</code>. Then you can import both FlatBuffers and the generated code to read or write FlatBuffers.</p>
<p>For example, here is how you would read a FlatBuffer binary file in Rust: First, include the library and generated code. Then read the file into a <code>u8</code> vector, which you pass, as a byte slice, to <code>root_as_monster()</code>.</p>
<p>This full example program is available in the Rust test suite: <a href="https://github.com/google/flatbuffers/blob/master/tests/rust_usage_test/bin/monster_example.rs">monster_example.rs</a></p>
<p>It can be run by <code>cd</code>ing to the <code>rust_usage_test</code> directory and executing: <code>cargo run monster_example</code>.</p>
<div class="fragment"><div class="line">extern crate flatbuffers;</div>
<div class="line"> </div>
<div class="line">#[allow(dead_code, unused_imports)]</div>
<div class="line">#[path = &quot;../../monster_test_generated.rs&quot;]</div>
<div class="line">mod monster_test_generated;</div>
<div class="line">pub use monster_test_generated::my_game;</div>
<div class="line"> </div>
<div class="line">use std::io::Read;</div>
<div class="line"> </div>
<div class="line">fn main() {</div>
<div class="line">    let mut f = std::fs::File::open(&quot;../monsterdata_test.mon&quot;).unwrap();</div>
<div class="line">    let mut buf = Vec::new();</div>
<div class="line">    f.read_to_end(&amp;mut buf).expect(&quot;file reading failed&quot;);</div>
<div class="line"> </div>
<div class="line">    let monster = my_game::example::root_as_monster(&amp;buf[..]);</div>
</div><!-- fragment --><p><code>monster</code> is of type <code>Monster</code>, and points to somewhere <em>inside</em> your buffer (root object pointers are not the same as <code>buffer_pointer</code> !). If you look in your generated header, you'll see it has convenient accessors for all fields, e.g. <code>hp()</code>, <code>mana()</code>, etc:</p>
<div class="fragment"><div class="line">    println!(&quot;{}&quot;, monster.hp());     // `80`</div>
<div class="line">    println!(&quot;{}&quot;, monster.mana());   // default value of `150`</div>
<div class="line">    println!(&quot;{:?}&quot;, monster.name()); // Some(&quot;MyMonster&quot;)</div>
<div class="line">}</div>
</div><!-- fragment --><p><em>Note: That we never stored a <code>mana</code> value, so it will return the default.</em></p>
<h1>Direct memory access</h1>
<p>As you can see from the above examples, all elements in a buffer are accessed through generated accessors. This is because everything is stored in little endian format on all platforms (the accessor performs a swap operation on big endian machines), and also because the layout of things is generally not known to the user.</p>
<p>For structs, layout is deterministic and guaranteed to be the same across platforms (scalars are aligned to their own size, and structs themselves to their largest member), and you are allowed to access this memory directly by using <code>safe_slice</code> on the reference to a struct, or even an array of structs.</p>
<p>To compute offsets to sub-elements of a struct, make sure they are structs themselves, as then you can use the pointers to figure out the offset without having to hardcode it. This is handy for use of arrays of structs with calls like <code>glVertexAttribPointer</code> in OpenGL or similar APIs.</p>
<p>It is important to note is that structs are still little endian on all machines, so the functions to enable tricks like this are only exposed on little endian machines. If you also ship on big endian machines, using an <code>#[cfg(target_endian = "little")]</code> attribute would be wise or your code will not compile.</p>
<p>The special function <code>safe_slice</code> is implemented on Vector objects that are represented in memory the same way as they are represented on the wire. This function is always available on vectors of struct, bool, u8, and i8. It is conditionally-compiled on little-endian systems for all the remaining scalar types.</p>
<p>The <a class="el" href="classFlatBufferBuilder.html" title="Helper class to hold data needed in creation of a FlatBuffer. To serialize data, you typically call o...">FlatBufferBuilder</a> function <code>create_vector_direct</code> is implemented for all types that are endian-safe to write with a <code>memcpy</code>. It is the write-equivalent of <code>safe_slice</code>.</p>
<h1>Access of untrusted buffers</h1>
<p>The safe Rust functions to interpret a slice as a table (<code>root</code>, <code>size_prefixed_root</code>, <code>root_with_opts</code>, and <code>size_prefixed_root_with_opts</code>) verify the data first. This has some performance cost, but is intended to be safe for use on flatbuffers from untrusted sources. There are corresponding <code>unsafe</code> versions with names ending in <code>_unchecked</code> which skip this verification, and may access arbitrary memory.</p>
<p>The generated accessor functions access fields over offsets, which is very quick. The current implementation uses these to access memory without any further bounds checking. All of the safe Rust APIs ensure the verifier is run over these flatbuffers before accessing them.</p>
<p>When you're processing large amounts of data from a source you know (e.g. your own generated data on disk), the <code>_unchecked</code> versions are acceptable, but when reading data from the network that can potentially have been modified by an attacker, it is desirable to use the safe versions which use the verifier.</p>
<h1>Threading</h1>
<p>Reading a FlatBuffer does not touch any memory outside the original buffer, and is entirely read-only (all immutable), so is safe to access from multiple threads even without synchronisation primitives.</p>
<p>Creating a FlatBuffer is not thread safe. All state related to building a FlatBuffer is contained in a <a class="el" href="classFlatBufferBuilder.html" title="Helper class to hold data needed in creation of a FlatBuffer. To serialize data, you typically call o...">FlatBufferBuilder</a> instance, and no memory outside of it is touched. To make this thread safe, either do not share instances of <a class="el" href="classFlatBufferBuilder.html" title="Helper class to hold data needed in creation of a FlatBuffer. To serialize data, you typically call o...">FlatBufferBuilder</a> between threads (recommended), or manually wrap it in synchronisation primitives. There's no automatic way to accomplish this, by design, as we feel multithreaded construction of a single buffer will be rare, and synchronisation overhead would be costly.</p>
<p>Unlike most other languages, in Rust these properties are exposed to and enforced by the type system. <code><a class="el" href="classflatbuffers_1_1Table.html">flatbuffers::Table</a></code> and the generated table types are <code>Send + Sync</code>, indicating they may be freely shared across threads and data may be accessed from any thread which receives a const (aka shared) reference. There are no functions which require a mutable (aka exclusive) reference, which means all the available functions may be called like this. <code><a class="el" href="namespaceflatbuffers.html#a41ac7b1c8f5f4a869e8f649b6c171ce7">flatbuffers::FlatBufferBuilder</a></code> is also <code>Send + Sync</code>, but all of the mutating functions require a mutable (aka exclusive) reference which can only be created when no other references to the <code><a class="el" href="classFlatBufferBuilder.html" title="Helper class to hold data needed in creation of a FlatBuffer. To serialize data, you typically call o...">FlatBufferBuilder</a></code> exist, and may not be copied within the same thread, let alone to a second thread.</p>
<h1>Useful tools created by others</h1>
<ul>
<li><a href="https://github.com/frol/flatc-rust">flatc-rust</a> - FlatBuffers compiler (flatc) as API for transparent <code>.fbs</code> to <code>.rs</code> code-generation via Cargo build scripts integration.</li>
</ul>
<p><br  />
 </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
