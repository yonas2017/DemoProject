<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Demo Project: Tutorial</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Demo Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Tutorial</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This tutorial provides an example of how to work with FlatBuffers in a variety of languages. The following topics will cover all the steps of using FlatBuffers in your application.</p>
<ol type="1">
<li>Writing a FlatBuffers schema file (<code>.fbs</code>).</li>
<li>Using the <code>flatc</code> compiler to transform the schema into language-specific code.</li>
<li>Importing the generated code and libraries into your application.</li>
<li>Serializing data into a flatbuffer.</li>
<li>Deserializing a flatbuffer.</li>
</ol>
<p>!!! note </p><pre class="fragment">The tutorial is structured to be language agnostic, with language specifics
in code blocks providing more context. Additionally, this tries to cover the
major parts and type system of flatbuffers to give a general overview. It's
not expected to be an exhaustive list of all features, or provide the best
way to do things.
</pre> <h1>FlatBuffers Schema (<code>.fbs</code>)</h1>
<p>To start working with FlatBuffers, you first need to create a <a class="el" href="md_flatbuffers_2docs_2source_2schema.html">schema</a> file which defines the format of the data structures you wish to serialize. The schema is processed by the <code>flatc</code> compiler to generate language-specific code that you use in your projects.</p>
<p>The following <a href="https://github.com/google/flatbuffers/blob/master/samples/monster.fbs"><code>monster.fbs</code></a> schema will be used for this tutorial. This is part of the FlatBuffers <a href="https://github.com/google/flatbuffers/tree/master/samples">sample code</a> to give complete sample binaries demonstrations.</p>
<p>FlatBuffers schema is a <a class="el" href="classInterface.html">Interface</a> Definition Language (IDL) that has a couple data structures, see the <a class="el" href="md_flatbuffers_2docs_2source_2schema.html">schema</a> documentation for a detail description. Use the inline code annotations to get a brief synopsis of each part of the schema.</p>
<div class="fragment"><div class="line"> title=<span class="stringliteral">&quot;monster.fbs&quot;</span> linenums=<span class="stringliteral">&quot;1&quot;</span></div>
<div class="line"><span class="comment">// Example IDL file for our monster&#39;s schema.</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>MyGame.Sample; <span class="comment">//(1)!</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">enum</span> <a class="code hl_enumeration" href="enums__generated_8h.html#a738b1b8abd03ae11a7632283c3a13ae3">Color</a>:<span class="keywordtype">byte</span> { Red = 0, Green, Blue = 2 } <span class="comment">//(2)!</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Optionally add more tables.</span></div>
<div class="line"><span class="keyword">union </span>Equipment { Weapon } <span class="comment">//(3)!</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>Vec3 { <span class="comment">//(4)!</span></div>
<div class="line">  <a class="code hl_variable" href="gmock-matchers-containers__test_8cc.html#a6150e0515f7202e2fb518f7206ed97dc">x</a>:float; <span class="comment">//(5)!</span></div>
<div class="line">  <a class="code hl_variable" href="gmock-matchers-containers__test_8cc.html#a39cb44155237f0205e0feb931d5acbed">y</a>:float;</div>
<div class="line">  <a class="code hl_variable" href="gmock-matchers-containers__test_8cc.html#a196ff6a287f53f758b1506f21269fc77">z</a>:float;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">table <a class="code hl_enumvalue" href="namespaceMyGame_1_1Example.html#ac1ea6e173e6c1b0fb8585ffc416d9b88a243a3afa44aed85d504dbd53fd9804e9">Monster</a> { <span class="comment">//(6)!</span></div>
<div class="line">  pos:Vec3; <span class="comment">//(7)!</span></div>
<div class="line">  mana:<span class="keywordtype">short</span> = 150; <span class="comment">//(8)!</span></div>
<div class="line">  hp:<span class="keywordtype">short</span> = 100;</div>
<div class="line">  <a class="code hl_variable" href="idl__gen__ts_8cpp.html#a9b45b3e13bd9167aab02e17e08916231">name</a>:<a class="code hl_typedef" href="namespacegrpc.html#a77f15e90a2c3651195f88645e4512267">string</a>; <span class="comment">//(9)!</span></div>
<div class="line">  friendly:<span class="keywordtype">bool</span> = <span class="keyword">false</span> (deprecated); <span class="comment">//(10)!</span></div>
<div class="line">  inventory:[ubyte]; <span class="comment">//(11)!</span></div>
<div class="line">  color:<a class="code hl_enumeration" href="enums__generated_8h.html#a738b1b8abd03ae11a7632283c3a13ae3">Color</a> = <a class="code hl_enumvalue" href="namespaceMyGame_1_1Example.html#a81381536b82036755d7887c398f14676a9594eec95be70e7b1710f730fdda33d9">Blue</a>;</div>
<div class="line">  weapons:[Weapon]; <span class="comment">//(12)!</span></div>
<div class="line">  equipped:<a class="code hl_enumeration" href="namespaceMyGame_1_1Sample.html#add5600c8554383eb7a8c7793a9da2a92">Equipment</a>; <span class="comment">//(13)!</span></div>
<div class="line">  <a class="code hl_variable" href="idl__gen__ts_8cpp.html#a4d455efceee21e97d8e21ee40e9b4a20">path</a>:[Vec3];</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">table Weapon {</div>
<div class="line">  <a class="code hl_variable" href="idl__gen__ts_8cpp.html#a9b45b3e13bd9167aab02e17e08916231">name</a>:<a class="code hl_typedef" href="namespacegrpc.html#a77f15e90a2c3651195f88645e4512267">string</a>;</div>
<div class="line">  damage:short;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">root_type <a class="code hl_enumvalue" href="namespaceMyGame_1_1Example.html#ac1ea6e173e6c1b0fb8585ffc416d9b88a243a3afa44aed85d504dbd53fd9804e9">Monster</a>; <span class="comment">//(14)!</span></div>
<div class="ttc" id="aenums__generated_8h_html_a738b1b8abd03ae11a7632283c3a13ae3"><div class="ttname"><a href="enums__generated_8h.html#a738b1b8abd03ae11a7632283c3a13ae3">Color</a></div><div class="ttdeci">Color</div><div class="ttdef"><b>Definition</b> enums_generated.h:16</div></div>
<div class="ttc" id="agmock-matchers-containers__test_8cc_html_a196ff6a287f53f758b1506f21269fc77"><div class="ttname"><a href="gmock-matchers-containers__test_8cc.html#a196ff6a287f53f758b1506f21269fc77">z</a></div><div class="ttdeci">Uncopyable z</div><div class="ttdef"><b>Definition</b> gmock-matchers-containers_test.cc:378</div></div>
<div class="ttc" id="agmock-matchers-containers__test_8cc_html_a39cb44155237f0205e0feb931d5acbed"><div class="ttname"><a href="gmock-matchers-containers__test_8cc.html#a39cb44155237f0205e0feb931d5acbed">y</a></div><div class="ttdeci">const double y</div><div class="ttdef"><b>Definition</b> gmock-matchers-containers_test.cc:377</div></div>
<div class="ttc" id="agmock-matchers-containers__test_8cc_html_a6150e0515f7202e2fb518f7206ed97dc"><div class="ttname"><a href="gmock-matchers-containers__test_8cc.html#a6150e0515f7202e2fb518f7206ed97dc">x</a></div><div class="ttdeci">int x</div><div class="ttdef"><b>Definition</b> gmock-matchers-containers_test.cc:376</div></div>
<div class="ttc" id="aidl__gen__ts_8cpp_html_a4d455efceee21e97d8e21ee40e9b4a20"><div class="ttname"><a href="idl__gen__ts_8cpp.html#a4d455efceee21e97d8e21ee40e9b4a20">path</a></div><div class="ttdeci">std::string path</div><div class="ttdef"><b>Definition</b> idl_gen_ts.cpp:47</div></div>
<div class="ttc" id="aidl__gen__ts_8cpp_html_a9b45b3e13bd9167aab02e17e08916231"><div class="ttname"><a href="idl__gen__ts_8cpp.html#a9b45b3e13bd9167aab02e17e08916231">name</a></div><div class="ttdeci">std::string name</div><div class="ttdef"><b>Definition</b> idl_gen_ts.cpp:36</div></div>
<div class="ttc" id="anamespaceMyGame_1_1Example_html_a81381536b82036755d7887c398f14676a9594eec95be70e7b1710f730fdda33d9"><div class="ttname"><a href="namespaceMyGame_1_1Example.html#a81381536b82036755d7887c398f14676a9594eec95be70e7b1710f730fdda33d9">MyGame::Example::Color::Blue</a></div><div class="ttdeci">@ Blue</div><div class="ttdoc">color Blue (1u &lt;&lt; 3)</div></div>
<div class="ttc" id="anamespaceMyGame_1_1Example_html_ac1ea6e173e6c1b0fb8585ffc416d9b88a243a3afa44aed85d504dbd53fd9804e9"><div class="ttname"><a href="namespaceMyGame_1_1Example.html#ac1ea6e173e6c1b0fb8585ffc416d9b88a243a3afa44aed85d504dbd53fd9804e9">MyGame::Example::Any::Monster</a></div><div class="ttdeci">@ Monster</div></div>
<div class="ttc" id="anamespaceMyGame_1_1Sample_html_add5600c8554383eb7a8c7793a9da2a92"><div class="ttname"><a href="namespaceMyGame_1_1Sample.html#add5600c8554383eb7a8c7793a9da2a92">MyGame::Sample::Equipment</a></div><div class="ttdeci">Equipment</div><div class="ttdef"><b>Definition</b> monster_generated.h:75</div></div>
<div class="ttc" id="anamespacegrpc_html_a77f15e90a2c3651195f88645e4512267"><div class="ttname"><a href="namespacegrpc.html#a77f15e90a2c3651195f88645e4512267">grpc::string</a></div><div class="ttdeci">GRPC_CUSTOM_STRING string</div><div class="ttdef"><b>Definition</b> cpp_generator.h:20</div></div>
</div><!-- fragment --><ol type="1">
<li>FlatBuffers has support for namespaces to place the generated code into. There is mixed level of support for namespaces (some languages don't have namespaces), but for the C family of languages, it is fully supported.</li>
<li>Enums definitions can be defined with the backing numerical type. Implicit numbering is supported, so that <code>Green</code> would have a value of 1.</li>
<li>A union represents a single value from a set of possible values. Its effectively an enum (to represent the type actually store) and a value, combined into one. In this example, the union is not very useful, since it only has a single type.</li>
<li>A struct is a collection of scalar fields with names. It is itself a scalar type, which uses less memory and has faster lookup. However, once a struct is defined, it cannot be changed. Use tables for data structures that can evolve over time.</li>
<li>FlatBuffers has the standard set of scalar numerical types (<code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code>, <code>uint8</code>, <code>uint16</code>, <code>uint32</code>, <code>uint64</code>, <code>float</code>, <code>double</code>), as well as <code>bool</code>. Note, scalars are fixed width, <code>varints</code> are not supported.</li>
<li>Tables are the main data structure for grouping data together. It can evolve by adding and deprecating fields over time, while preserving forward and backwards compatibility.</li>
<li>A field that happens to be a <code>struct</code>. This means the data of the <code>Vec3</code> struct will be serialized inline in the table without any need for offset.</li>
<li>Fields can be provided a default value. Default values can be configured to not be serialized at all while still providing the default value while deserializing. However, once set, a default value cannot be changed.</li>
<li>A <code>string</code> field which points to a serialized string external to the table.</li>
<li>A deprecated field that is no longer being used. This is used instead of removing the field outright.</li>
<li>A <code>vector</code> field that points to a vector of bytes. Like <code>strings</code>, the vector data is serialized elsewhere and this field just stores an offset to the vector.</li>
<li>Vector of <code>tables</code> and <code>structs</code> are also possible.</li>
<li>A field to a <code>union</code> type.</li>
<li>The root of the flatbuffer is always a <code>table</code>. This indicates the type of <code>table</code> the "entry" point of the flatbuffer will point to.</li>
</ol>
<p>!!! bug "Get FlatBuffers schema syntax highlighting"</p>
<h1>Compiling Schema to Code (<code>flatc</code>)</h1>
<p>After a schema file is written, you compile it to code in the languages you wish to work with. This compilation is done by the <a class="el" href="md_flatbuffers_2docs_2source_2flatc.html">FlatBuffers Compiler</a> (<code>flatc</code>) which is one of the binaries built in the repo.</p>
<h2>Building <code>flatc</code></h2>
<p>FlatBuffers uses <a href="https://cmake.org/"><code>cmake</code></a> to build projects files for your environment.</p>
<p>=== "Unix" </p><pre class="fragment">```sh
cmake -G "Unix Makefiles"
make flatc
```
</pre><p> === "Windows" </p><pre class="fragment">```sh
cmake -G "Visual Studio 17 2022"
msbuild.exe FlatBuffers.sln
```
</pre><p> See the documentation on <a class="el" href="md_flatbuffers_2docs_2source_2building.html">building</a> for more details and other environments. Some languages also include a prebuilt <code>flatc</code> via their package manager.</p>
<h2>Compiling Schema</h2>
<p>To compile the schema, invoke <code>flatc</code> with the schema file and the language flags you wish to generate code for. This compilation will generate files that you include in your application code. These files provide convenient APIs for serializing and deserializing the flatbuffer binary data.</p>
<p>=== "C++" </p><pre class="fragment">```sh
flatc --cpp monster.fbs
```
</pre><p> === "C#" </p><pre class="fragment">```sh
flatc --csharp monster.fbs
```
</pre><p> !!! tip </p><pre class="fragment">You can deserialize flatbuffers in languages that differ from the language
that serialized it. For purpose of this tutorial, we assume one language
is used for both serializing and deserializing.
</pre> <h1>Application Integration</h1>
<p>The generated files are then included in your project to be built into your application. This is heavily dependent on your build system and language, but generally involves two things:</p>
<ol type="1">
<li>Importing the generated code.</li>
<li>Importing the "runtime" libraries.</li>
</ol>
<p>=== "C++" </p><pre class="fragment">```c++
#include "monster_generated.h" // This was generated by `flatc`
#include "flatbuffers.h" // The runtime library for C++

// Simplifies naming in the following examples.
using namespace MyGame::Sample; // Specified in the schema.
```
</pre><p> === "C#" </p><pre class="fragment">```c#
using Google.FlatBuffers; // The runtime library for C#
using MyGame.Sample; // The generated files from `flatc`
```
</pre><p> For some languages the runtime libraries are just code files you compile into your application. While other languages provide packaged libraries via their package managers.</p>
<p>!!! note </p><pre class="fragment">The generated files include APIs for both serializing and deserializing
flatbuffers. So these steps are identical for both the consumer and
producer.
</pre> <h1>Serialization</h1>
<p>Once all the files are included into your application, it's time to start serializing some data!</p>
<p>With FlatBuffers, serialization can be a bit verbose, since each piece of data must be serialized separately and in a particular order (depth-first, pre-order traversal). The verbosity allows efficient serialization without heap allocations, at the cost of more complex serialization APIs.</p>
<p>For example, any reference type (e.g. <code>table</code>, <code>vector</code>, <code>string</code>) must be serialized before it can be referred to by other structures. So its typical to serialize the data from leaf to root node, as will be shown below.</p>
<h2><a class="el" href="classFlatBufferBuilder.html" title="Helper class to hold data needed in creation of a FlatBuffer. To serialize data, you typically call o...">FlatBufferBuilder</a></h2>
<p>Most languages use a Builder object for managing the binary array that the data is serialized into. It provides an API for serializing data, as well as keeps track of some internal state. The generated code wraps methods on the Builder object to provide an API tailored to the schema.</p>
<p>First instantiate a Builder (or reuse an existing one) and specify some memory for it. The builder will automatically resize the backing buffer when necessary.</p>
<p>=== "C++" </p><pre class="fragment">```c++
// Construct a Builder with 1024 byte backing array.
flatbuffers::FlatBufferBuidler builder(1024);
```
</pre><p> === "C#" </p><pre class="fragment">```c#
// Construct a Builder with 1024 byte backing array.
FlatBufferBuilder builder = new FlatBufferBuilder(1024);
```
</pre><p> Once a Builder is available, data can be serialized to it via the Builder APIs and the generated code.</p>
<h2>Serializing Data</h2>
<p>In this tutorial, we are building <code>Monsters</code> and <code>Weapons</code> for a computer game. A <code>Weapon</code> is represented by a flatbuffer <code>table</code> with some fields. One field is the <code>name</code> field, which is type <code>string</code>.</p>
<div class="fragment"><div class="line"> title=<span class="stringliteral">&quot;monster.fbs&quot;</span> linenums=<span class="stringliteral">&quot;28&quot;</span></div>
<div class="line">table Weapon {</div>
<div class="line">  <a class="code hl_variable" href="idl__gen__ts_8cpp.html#a9b45b3e13bd9167aab02e17e08916231">name</a>:string;</div>
<div class="line">  damage:short;</div>
<div class="line">}</div>
</div><!-- fragment --><h3>Strings</h3>
<p>Since <code>string</code> is a reference type, we first need to serialize it before assigning it to the <code>name</code> field of the <code>Weapon</code> table. This is done through the Builder <code>CreateString</code> method:</p>
<p>=== "C++" </p><pre class="fragment">```c++
flatbuffers::Offset&lt;String&gt; weapon_one_name = builder.CreateString("Sword");
flatbuffers::Offset&lt;String&gt; weapon_two_name = builder.CreateString("Axe");
```
</pre><p> === "C#" </p><pre class="fragment">```c#
Offset&lt;String&gt; weaponOneName = builder.CreateString("Sword");
Offset&lt;String&gt; weaponTwoName = builder.CreateString("Axe");
```
</pre><p> This performs the actual serialization (the string data is copied into the backing array) and returns an offset. Think of the offset as a handle to that reference. It's just a "typed" numerical offset to where that data resides in the buffer.</p>
<h3>Tables</h3>
<p>Now that we have some names serialized, we can serialize <code>Weapons</code>. Here we will use one of the generated helper functions that was emitted by <code>flatc</code>. The <code>CreateWeapon</code> function takes in the Builder object, as well as the offset to the weapon's name and a numerical value for the damage field.</p>
<p>=== "C++" </p><pre class="fragment">```c++
short weapon_one_damage = 3;
short weapon_two_damage = 5;

// Use the `CreateWeapon()` shortcut to create Weapons with all the fields set.
flatbuffers::Offset&lt;Weapon&gt; sword =
    CreateWeapon(builder, weapon_one_name, weapon_one_damage);
flatbuffers::Offset&lt;Weapon&gt; axe =
    CreateWeapon(builder, weapon_two_name, weapon_two_damage);
```
</pre><p> === "C#" </p><pre class="fragment">```c#
short weaponOneDamage = 3;
short weaponTwoDamage = 5;

// Use the `CreateWeapon()` helper function to create the weapons, since we set every field.
Offset&lt;Weapon&gt; sword =
    Weapon.CreateWeapon(builder, weaponOneName, weaponOneDamage);
Offset&lt;Weapon&gt; axe =
    Weapon.CreateWeapon(builder, weaponTwoName, weaponTwoDamage);
```
</pre><p> !!! Tip </p><pre class="fragment">The generated functions from `flatc`, like `CreateWeapon`, are just composed
of various Builder API methods. So its not required to use the generated
code, but it does make things much simpler and compact.
</pre><p> Just like the <code>CreateString</code> methods, the table serialization functions return an offset to the location of the serialized <code>Weapon</code> table.</p>
<p>Now that we have some <code>Weapons</code> serialized, we can serialize a <code>Monster</code>. Looking at the schema again, this table has a lot more fields of various types. Some of these need to be serialized beforehand, for the same reason we serialized the name string before the weapon table.</p>
<p>!!! note inline end </p><pre class="fragment">There is no prescribed ordering of which table fields must be serialized
first, you could serialize in any order you want. You can also not serialize
a field to provide a `null` value, this is done by using an 0 offset value.
</pre> <div class="fragment"><div class="line"> title=<span class="stringliteral">&quot;monster.fbs&quot;</span> linenums=<span class="stringliteral">&quot;15&quot;</span></div>
<div class="line">table Monster {</div>
<div class="line">  pos:Vec3;</div>
<div class="line">  mana:<span class="keywordtype">short</span> = 150;</div>
<div class="line">  hp:<span class="keywordtype">short</span> = 100;</div>
<div class="line">  <a class="code hl_variable" href="idl__gen__ts_8cpp.html#a9b45b3e13bd9167aab02e17e08916231">name</a>:string;</div>
<div class="line">  friendly:<span class="keywordtype">bool</span> = <span class="keyword">false</span> (deprecated);</div>
<div class="line">  inventory:[ubyte];</div>
<div class="line">  color:<a class="code hl_enumeration" href="enums__generated_8h.html#a738b1b8abd03ae11a7632283c3a13ae3">Color</a> = Blue;</div>
<div class="line">  weapons:[Weapon];</div>
<div class="line">  equipped:Equipment;</div>
<div class="line">  <a class="code hl_variable" href="idl__gen__ts_8cpp.html#a4d455efceee21e97d8e21ee40e9b4a20">path</a>:[Vec3];</div>
<div class="line">}</div>
</div><!-- fragment --><h3>Vectors</h3>
<p>The <code>weapons</code> field is a <code>vector</code> of <code>Weapon</code> tables. We already have two <code>Weapons</code> serialized, so we just need to serialize a <code>vector</code> of those offsets. The Builder provides multiple ways to create <code>vectors</code>.</p>
<p>=== "C++" </p><pre class="fragment">```c++
// Create a std::vector of the offsets we had previous made.
std::vector&lt;flatbuffers::Offset&lt;Weapon&gt;&gt; weapons_vector;
weapons_vector.push_back(sword);
weapons_vector.push_back(axe);

// Then serialize that std::vector into the buffer and again get an Offset
// to that vector. Use `auto` here since the full type is long, and it just
// a "typed" number.
auto weapons = builder.CreateVector(weapons_vector);
```
</pre><p> === "C#" </p><pre class="fragment">```c#
// Create an array of the two weapon offsets.
var weaps = new Offset&lt;Weapon&gt;[2];
weaps[0] = sword;
weaps[1] = axe;

// Pass the `weaps` array into the `CreateWeaponsVector()` method to create
// a FlatBuffer vector.
var weapons = Monster.CreateWeaponsVector(builder, weaps);
```
</pre><p> While we are at it, let us serialize the other two vector fields: the <code>inventory</code> field is just a vector of scalars, and the <code>path</code> field is a vector of structs (which are scalar data as well). So these vectors can be serialized a bit more directly.</p>
<p>=== "C++" </p><pre class="fragment">```c++
// Construct an array of two `Vec3` structs.
Vec3 points[] = { Vec3(1.0f, 2.0f, 3.0f), Vec3(4.0f, 5.0f, 6.0f) };

// Serialize it as a vector of structs.
flatbuffers::Offset&lt;flatbuffers::Vector&lt;Vec3&gt;&gt; path =
    builder.CreateVectorOfStructs(points, 2);

// Create a `vector` representing the inventory of the Orc. Each number
// could correspond to an item that can be claimed after he is slain.
unsigned char treasure[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
flatbuffers::Offset&lt;flatbuffers::Vector&lt;unsigned char&gt;&gt; inventory =
    builder.CreateVector(treasure, 10);

```
</pre><p> === "C#" </p><pre class="fragment">```c#
// Start building a path vector of length 2.
Monster.StartPathVector(fbb, 2);

// Serialize the individual Vec3 structs
Vec3.CreateVec3(builder, 1.0f, 2.0f, 3.0f);
Vec3.CreateVec3(builder, 4.0f, 5.0f, 6.0f);

// End the vector to get the offset
Offset&lt;Vector&lt;Vec3&gt;&gt; path = fbb.EndVector();

// Create a `vector` representing the inventory of the Orc. Each number
// could correspond to an item that can be claimed after he is slain.
// Note: Since we prepend the bytes, this loop iterates in reverse order.
Monster.StartInventoryVector(builder, 10);
for (int i = 9; i &gt;= 0; i--)
{
    builder.AddByte((byte)i);
}
Offset&lt;Vector&lt;byte&gt;&gt; inventory = builder.EndVector();
```
</pre> <h3>Unions</h3>
<p>The last non-scalar data for the <code>Monster</code> table is the <code>equipped</code> <code>union</code> field. For this case, we will reuse an already serialized <code>Weapon</code> (the only type in the union), without needing to reserialize it. Union fields implicitly add a hidden <code>_type</code> field that stores the type of value stored in the union. When serializing a union, you must explicitly set this type field, along with providing the union value.</p>
<p>We will also serialize the other scalar data at the same time, since we have all the necessary values and Offsets to make a <code>Monster</code>.</p>
<p>=== "C++" </p><pre class="fragment">```c++
// Create the remaining data needed for the Monster.
auto name = builder.CreateString("Orc");

// Create the position struct
auto position = Vec3(1.0f, 2.0f, 3.0f);

// Set his hit points to 300 and his mana to 150.
int hp = 300;
int mana = 150;

// Finally, create the monster using the `CreateMonster` helper function
// to set all fields.
//
// Here we set the union field by using the `.Union()` method of the
// `Offset&lt;Weapon&gt;` axe we already serialized above. We just have to specify
// which type of object we put in the union, and do that with the
// auto-generated `Equipment_Weapon` enum.
flatbuffers::Offset&lt;Monster&gt; orc =
    CreateMonster(builder, &amp;position, mana, hp, name, inventory,
                  Color_Red, weapons, Equipment_Weapon, axe.Union(),
                  path);

```
</pre><p> === "C#" </p><pre class="fragment">```c#
// Create the remaining data needed for the Monster.
var name = builder.CreateString("Orc");

// Create our monster using `StartMonster()` and `EndMonster()`.
Monster.StartMonster(builder);
Monster.AddPos(builder, Vec3.CreateVec3(builder, 1.0f, 2.0f, 3.0f));
Monster.AddHp(builder, (short)300);
Monster.AddName(builder, name);
Monster.AddInventory(builder, inv);
Monster.AddColor(builder, Color.Red);
Monster.AddWeapons(builder, weapons);
// For union fields, we explicitly add the auto-generated enum for the type
// of value stored in the union.
Monster.AddEquippedType(builder, Equipment.Weapon);
// And we just use the `.Value` property of the already serialized axe.
Monster.AddEquipped(builder, axe.Value); // Axe
Monster.AddPath(builder, path);
Offset&lt;Monster&gt; orc = Monster.EndMonster(builder);
```
</pre><p> !!! warning </p><pre class="fragment">When serializing tables, you must fully serialize it before attempting to
serialize another reference type. If you try to serialize in a nested
manner, you will get an assert/exception/panic depending on your language.
</pre> <h2>Finishing</h2>
<p>At this point, we have serialized a <code>Monster</code> we've named "orc" to the flatbuffer and have its offset. The <code>root_type</code> of the schema is also a <code>Monster</code>, so we have everything we need to finish the serialization step.</p>
<p>This is done by calling the appropriate <code>finish</code> method on the Builder, passing in the orc offset to indicate this <code>table</code> is the "entry" point when deserializing the buffer later.</p>
<p>=== "C++" </p><pre class="fragment">```c++
// Call `Finish()` to instruct the builder that this monster is complete.
// You could also call `FinishMonsterBuffer(builder, orc);`
builder.Finish(orc);
```
</pre><p> === "C#" </p><pre class="fragment">```c#
// Call `Finish()` to instruct the builder that this monster is complete.
// You could also call `Monster.FinishMonsterBuffer(builder, orc);`
builder.Finish(orc.Value);
```
</pre><p> Once you finish a Builder, you can no longer serialize more data to it.</p>
<h3>Buffer Access</h3>
<p>The flatbuffer is now ready to be stored somewhere, sent over the network, compressed, or whatever you would like to do with it. You access the raw buffer like so:</p>
<p>=== "C++" </p><pre class="fragment">```c++
// This must be called after `Finish()`.
uint8_t *buf = builder.GetBufferPointer();

// Returns the size of the buffer that `GetBufferPointer()` points to.
int size = builder.GetSize();
```
</pre><p> === "C#" </p><pre class="fragment">```c#
// This must be called after `Finish()`.
//
// The data in this ByteBuffer does NOT start at 0, but at buf.Position.
// The end of the data is marked by buf.Length, so the size is
// buf.Length - buf.Position.
FlatBuffers.ByteBuffer dataBuffer = builder.DataBuffer;

// Alternatively this copies the above data out of the ByteBuffer for you:
byte[] buf = builder.SizedByteArray();
```
</pre><p> Now you can write the bytes to a file or send them over the network. The buffer stays valid until the Builder is cleared or destroyed.</p>
<p>!!! warning "BINARY Mode" </p><pre class="fragment">Make sure your file mode (or transfer protocol) is set to BINARY, and not
TEXT. If you try to transfer a flatbuffer in TEXT mode, the buffer will be
corrupted and be hard to diagnose.
</pre> <h1>Deserialization</h1>
<p>!!! note "Misnomer" </p><pre class="fragment">Deserialization is a bit of a misnomer, since FlatBuffers doesn't
deserialize the whole buffer when accessed. It just "decodes" the data that
is requested, leaving all the other data untouched. It is up to the
application to decide if the data is copied out or even read in the first
place. However, we continue to use the word `deserialize` to mean accessing
data from a binary flatbuffer.
</pre><p> Now that we have successfully create an orc FlatBuffer, the data can be saved, sent over a network, etc. At some point, the buffer will be accessed to obtain the underlying data.</p>
<p>The same application setup used for serialization is needed for deserialization (see application integration).</p>
<h2>Root Access</h2>
<p>All access to the data in the flatbuffer must first go through the root object. There is only one root object per flatbuffer. The generated code provides functions to get the root object given the buffer.</p>
<p>=== "C++" </p><pre class="fragment">```c++
uint8_t *buffer_pointer = /* the data you just read */;

// Get an view to the root object inside the buffer.
Monster monster = GetMonster(buffer_pointer);
```
</pre><p> === "C#" </p><pre class="fragment">```c#
byte[] bytes = /* the data you just read */

// Get an view to the root object inside the buffer.
Monster monster = Monster.GetRootAsMonster(new ByteBuffer(bytes));
```
</pre><p> !!! warning "BINARY mode" </p><pre class="fragment">Again, make sure you read the bytes in BINARY mode, otherwise the buffer may
be corrupted.
</pre><p> In most languages, the returned object is just a "view" of the data with helpful accessors. Data is typically not copied out of the backing buffer. This also means the backing buffer must remain alive for the duration of the views.</p>
<h2>Table Access</h2>
<p>If you look in the generated files emitted by <code>flatc</code>, you will see it generated , for each <code>table</code>, accessors of all its non-<code>deprecated</code> fields. For example, some of the accessors of the <code>Monster</code> root table would look like:</p>
<p>=== "C++" </p><pre class="fragment">```c++
auto hp = monster-&gt;hp();
auto mana = monster-&gt;mana();
auto name = monster-&gt;name()-&gt;c_str();
```
</pre><p> === "C#" </p><pre class="fragment">```c#
// For C#, unlike most other languages support by FlatBuffers, most values
// (except for vectors and unions) are available as properties instead of
// accessor methods.
var hp = monster.Hp;
var mana = monster.Mana;
var name = monster.Name;
```
</pre><p> These accessors should hold the values <code>300</code>, <code>150</code>, and <code>"Orc"</code> respectively.</p>
<p>!!! note "Default Values" </p><pre class="fragment">The default value of `150` wasn't stored in the `mana` field, but we are
still able to retrieve it. That is because the generated accessors return a
hard-coded default value when it doesn't find the value in the buffer.
</pre> <h3>Nested Object Access</h3>
<p>Accessing nested objects is very similar, with the nested field pointing to another object type. Be careful, the field could be <code>null</code> if not present.</p>
<p>For example, accessing the <code>pos</code> <code>struct</code>, which is type <code>Vec3</code> you would do:</p>
<p>=== "C++" </p><pre class="fragment">```c++
auto pos = monster-&gt;pos();
auto x = pos-&gt;x();
auto y = pos-&gt;y();
auto z = pos-&gt;z();
```
</pre><p> === "C#" </p><pre class="fragment">```c#
var pos = monster.Pos.Value;
var x = pos.X;
var y = pos.Y;
var z = pos.Z;
```
</pre><p> Where <code>x</code>, <code>y</code>, and <code>z</code> will contain <code>1.0</code>, <code>2.0</code>, and <code>3.0</code> respectively.</p>
<h2>Vector Access</h2>
<p>Similarly, we can access elements of the <code>inventory</code> <code>vector</code> by indexing it. You can also iterate over the length of the vector.</p>
<p>=== "C++" </p><pre class="fragment">```c++
flatbuffers::Vector&lt;unsigned char&gt; inv = monster-&gt;inventory();
auto inv_len = inv-&gt;size();
auto third_item = inv-&gt;Get(2);
```
</pre><p> === "C#" </p><pre class="fragment">```c#
int invLength = monster.InventoryLength;
var thirdItem = monster.Inventory(2);
```
</pre><p> For vectors of tables, you can access the elements like any other vector, except you need to handle the result as a FlatBuffer table. Here we iterate over the <code>weapons</code> vector that is houses <code>Weapon</code> <code>tables</code>.</p>
<p>=== "C++" </p><pre class="fragment">```c++
flatbuffers::Vector&lt;Weapon&gt; weapons = monster-&gt;weapons();
auto weapon_len = weapons-&gt;size();
auto second_weapon_name = weapons-&gt;Get(1)-&gt;name()-&gt;str();
auto second_weapon_damage = weapons-&gt;Get(1)-&gt;damage()
```
</pre><p> === "C#" </p><pre class="fragment">```c#
int weaponsLength = monster.WeaponsLength;
var secondWeaponName = monster.Weapons(1).Name;
var secondWeaponDamage = monster.Weapons(1).Damage;
```
</pre> <h2>Union Access</h2>
<p>Lastly , we can access our <code>equipped</code> <code>union</code> field. Just like when we created the union, we need to get both parts of the union: the type and the data.</p>
<p>We can access the type to dynamically cast the data as needed (since the union only stores a FlatBuffer <code>table</code>).</p>
<p>=== "C++" </p><pre class="fragment">```c++
auto union_type = monster.equipped_type();

if (union_type == Equipment_Weapon) {
     // Requires `static_cast` to type `const Weapon*`.
    auto weapon = static_cast&lt;const Weapon*&gt;(monster-&gt;equipped());

    auto weapon_name = weapon-&gt;name()-&gt;str(); // "Axe"
    auto weapon_damage = weapon-&gt;damage();    // 5
}
```
</pre><p> === "C#" </p><pre class="fragment">```c#
var unionType = monster.EquippedType;

if (unionType == Equipment.Weapon) {
    var weapon = monster.Equipped&lt;Weapon&gt;().Value;

    var weaponName = weapon.Name;     // "Axe"
    var weaponDamage = weapon.Damage; // 5
}
```
</pre> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
